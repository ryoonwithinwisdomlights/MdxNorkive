---
title: '[TIL] 테스트 작성 (Testing) 가이드'
slug: techs-TIL-테스트-작성-Testing-가이드
summary: ''
pageCover: >-
  https://images.unsplash.com/photo-1593062096033-9a26b09da705?ixlib=rb-4.0.3&q=85&fm=jpg&crop=entropy&cs=srgb
notionId: 29f1eb5c033780ce8007d0daffd085dd
password: ''
type: Techs
doc_type: TIL
category: TIL
tags:
  - 개발TIL
  - 기술로그
favorite: false
date: '2025-11-02'
lastEditedTime: '2025-11-06T13:11:00.000Z'
draft: false
description: ''
icon: ''
full: false
readingTime: 39
wordCount: 7606
status: published
author: ryoonwithinwisdomlights
version: 1.0.0
---

## 📋 테스트 작성이란?


코드가 예상대로 동작하는지 확인하는 <strong>자동화된 코드</strong>를 작성하는 것입니다.


### 간단한 비유

- <strong>테스트 없이</strong>: 매번 손으로 버튼을 눌러서 확인 (수동 테스트)
- <strong>테스트 있으면</strong>: 자동으로 버튼을 눌러서 확인 (자동 테스트)

---


## 🎯 왜 필요한가?


### 1. <strong>버그 예방</strong>


코드를 수정할 때 기존 기능이 깨지지 않았는지 확인


### 2. <strong>코드 신뢰성</strong>


함수나 클래스가 정확하게 동작한다는 보장


### 3. <strong>리팩토링 안전성</strong>


코드 구조를 개선할 때 기능이 그대로 작동하는지 확인


### 4. <strong>문서화 효과</strong>


테스트 코드 자체가 사용 예시가 됨


---


## 📝 테스트 종류


### 1. Unit Test (단위 테스트)


<strong>개별 함수나 클래스</strong>가 제대로 동작하는지 테스트


<strong>예시</strong>:


```typescript
// media-processor.test.tsdescribe('MediaProcessor', () => {
  it('should process Notion image URLs', async () => {
    const processor = createMediaProcessor({
      uploader: mockUploader
    });

    const content = '![image.jpg](https://notion.so/image.webp?format=webp&quality=85)';
    const result = await processor.processNotionImages(content);

    expect(result).toContain('cloudinary.com');
  });
});
```


### 2. Integration Test (통합 테스트)


여러 모듈이 <strong>함께</strong> 잘 동작하는지 테스트


### 3. E2E Test (End-to-End 테스트)


전체 워크플로우를 처음부터 끝까지 테스트


---


## 🔍 현재 프로젝트 상황


### 현재 상태


✅ <strong>수동 테스트 사용 중</strong>:

- <code>npm run generate:mdx</code> 실행해서 확인
- <code>npm run validate:mdx</code> 실행해서 확인
- 직접 눈으로 확인

❌ <strong>자동 테스트 없음</strong>:

- 테스트 파일(<code>.test.ts</code>, <code>.spec.ts</code>) 없음
- 테스트 라이브러리 설치 안 됨

### 왜 지금은 테스트가 없나?

1. 패키지가 실제로 작동함 (<code>npm run generate:mdx</code> 확인됨)
2. 수동 테스트로 충분함
3. 배포가 더 우선순위

---


## 🛠️ 테스트 작성 예시


### 일반적인 테스트 라이브러리

1. <strong>Jest</strong> - 가장 널리 사용 (React 생태계)
2. <strong>Vitest</strong> - Vite 기반, 매우 빠름
3. <strong>Node Test Runner</strong> - Node.js 내장 (추가 설치 불필요)

### 예시 구조


```typescript
// packages/mdx-media-processor/src/media-processor.test.tsimport { describe, it, expect, beforeEach } from 'vitest';
import { createMediaProcessor } from './factory';
import type { CloudinaryUploader, CacheManager } from './types';

// Mock 업로더 (실제 Cloudinary 대신 가짜 함수)const mockUploader: CloudinaryUploader = {
  uploadFileFromUrl: async (url, fileName) => {
    return {
      secure_url: 'https://example.com/uploaded.jpg',
      public_id: fileName,
      width: 100,
      height: 100,
      format: 'jpg',
      bytes: 1024,
    };
  },
};

// Mock 캐시 (실제 Redis 대신 가짜 함수)const mockCache: CacheManager = {
  getCachedImageUrl: async () => null,
  cacheImageUrl: async () => {},
};

describe('MediaProcessor', () => {
  let processor: ReturnType<typeof createMediaProcessor>;

  beforeEach(() => {
    processor = createMediaProcessor({
      uploader: mockUploader,
      cache: mockCache,
    });
  });

  describe('processNotionImages', () => {
    it('should convert Notion image URLs', async () => {
      const content = '![image.jpg](https://notion.so/image.webp?format=webp&quality=85)';
      const result = await processor.processNotionImages(content);

      expect(result).toContain('example.com');
      expect(result).not.toContain('notion.so');
    });

    it('should handle HTML img tags', async () => {
      const content = '<img src="https://notion.so/image.webp?format=webp&quality=85" alt="test" />';
      const result = await processor.processNotionImages(content);

      expect(result).toContain('example.com');
    });

    it('should not process non-Notion URLs', async () => {
      const content = '![image.jpg](https://example.com/image.webp?format=webp&quality=85)';
      const result = await processor.processNotionImages(content);

      expect(result).toBe(content);// 변경 없음
    });
  });

  describe('processDocumentLinks', () => {
    it('should convert PDF links', async () => {
      const content = '<FileWrapper names={"document.pdf"} urls={"https://notion.so/file.pdf"} />';
      const result = await processor.processDocumentLinks(content);

      expect(result).toContain('example.com');
    });
  });

  describe('extractFileName', () => {
    it('should extract file name from URL', () => {
      const url = 'https://example.com/path/to/image.jpg?query=123';
      const fileName = processor.extractFileName(url);

      expect(fileName).toBe('image.jpg');
    });
  });

  describe('Statistics', () => {
    it('should track processed images count', async () => {
      processor.resetStats();

      await processor.processNotionImages('![img.jpg](https://notion.so/img.webp?format=webp&quality=85)');

      const stats = processor.getImageStats();
      expect(stats.processedImagesCount).toBe(1);
    });
  });
});
```


### 테스트 실행


```bash
# Vitest 설치
npm install -D vitest

# package.json에 추가
{
  "scripts": {
    "test": "vitest",
    "test:watch": "vitest --watch"
  }
}

# 테스트 실행
npm test
```


---


## ✅ 테스트 작성의 장단점


### 장점

1. ✅ <strong>자동화</strong>: 한 번 작성하면 계속 사용
2. ✅ <strong>안정성</strong>: 코드 변경 시 자동으로 확인
3. ✅ <strong>문서화</strong>: 테스트가 사용 예시
4. ✅ <strong>리팩토링 용이</strong>: 안전하게 코드 개선 가능
5. ✅ <strong>버그 발견</strong>: 예상치 못한 문제 발견

### 단점

1. ❌ <strong>시간 소요</strong>: 테스트 작성에 시간이 걸림
2. ❌ <strong>유지보수</strong>: 코드 변경 시 테스트도 수정 필요
3. ❌ <strong>과도한 테스트</strong>: 모든 것을 테스트할 필요는 없음
4. ❌ <strong>복잡도</strong>: 간단한 유틸리티는 테스트가 과할 수 있음

---


## 🤔 지금 해야 하나?


### 현재는 하지 않아도 되는 이유

1. ✅ 패키지가 실제로 작동함 (<code>npm run generate:mdx</code> 확인됨)
2. ✅ 수동 테스트로 충분함
3. ✅ 배포가 더 우선순위

### 나중에 추가하면 좋은 경우

1. 📦 사용자가 많아지고 버그가 생길 때
2. 🔧 기능이 복잡해질 때
3. 🌍 오픈소스로 활발히 공유할 때
4. 🐛 버그를 여러 번 발견했을 때

---


## 📊 테스트 커버리지


테스트 커버리지는 코드의 <strong>몇 %를 테스트했는지</strong>를 나타냅니다.


```plain text
코드 100줄 중 80줄 테스트 = 80% 커버리지
```


### 목표 커버리지

- <strong>핵심 기능</strong>: 80-100% (가장 중요)
- <strong>유틸리티 함수</strong>: 70-80% (충분)
- <strong>전체 패키지</strong>: 60-70% (합리적)

---


## 🎯 패키지별 테스트 우선순위


### 높은 우선순위 (테스트 작성 권장)

1. <strong>@norkive/mdx-safe-processor</strong>
    - XSS 방지 - 보안 관련이라 중요
    - 링크 변환 로직 - 복잡한 정규식 처리
2. <strong>@norkive/mdx-media-processor</strong>
    - 이미지/문서 처리 로직
    - 통계 수집 기능

### 중간 우선순위 (선택적)

1. <strong>@norkive/youtube-utils</strong>
    - URL 파싱 로직 (간단하지만 중요한 기능)
2. <strong>@norkive/mdx-validator</strong>
    - 검증 로직

### 낮은 우선순위

1. <strong>@norkive/lite-youtube-embed</strong>
    - React 컴포넌트 (시각적 테스트가 더 중요)

---


## 💡 테스트 작성 Best Practices


### 1. 의미 있는 테스트 이름


```typescript
// ❌ 나쁜 예it('test1', () => { ... });

// ✅ 좋은 예it('should convert Notion image URLs to Cloudinary URLs', () => { ... });
```


### 2. 하나의 테스트는 하나의 동작만


```typescript
// ❌ 나쁜 예 - 여러 가지를 한 번에it('should process images and documents', () => { ... });

// ✅ 좋은 예 - 각각 따로it('should process images', () => { ... });
it('should process documents', () => { ... });
```


### 3. Mock 사용 (외부 서비스 대신)


```typescript
// ✅ 실제 Cloudinary 대신 Mock 사용const mockUploader = {
  uploadFileFromUrl: async () => ({ secure_url: '...' }),
};
```


### 4. Edge Case 테스트


```typescript
// 일반적인 경우뿐만 아니라it('should handle empty content', () => { ... });
it('should handle invalid URLs', () => { ... });
it('should handle null values', () => { ... });
```


---


## 📚 참고 자료


### 테스트 라이브러리 문서

- [Vitest 공식 문서](https://vitest.dev/)
- [Jest 공식 문서](https://jestjs.io/)
- [Node.js Test Runner](https://nodejs.org/api/test.html)

### 테스트 작성 패턴

- <strong>AAA 패턴</strong>: Arrange (준비) → Act (실행) → Assert (확인)
- <strong>Given-When-Then</strong>: Given (주어진 조건) → When (실행) → Then (결과)

---


## ✅ 결론


### 지금 할 필요 없음

- 패키지가 작동하는 것을 확인했음
- 수동 테스트로 충분함
- 배포가 더 우선순위

### 나중에 추가 가능

- 사용자가 많아질 때
- 버그가 반복적으로 발견될 때
- 기능이 복잡해질 때

### 테스트는 도구일 뿐

- 테스트가 모든 것을 해결하는 것은 아님
- 과도한 테스트는 시간 낭비
- 적절한 균형이 중요

---


<strong>작성일</strong>: 2025-11-02


<strong>목적</strong>: 테스트 작성에 대한 이해 및 향후 계획 수립

