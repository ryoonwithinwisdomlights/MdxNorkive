---
title: Mdx Norkive
slug: projects-Mdx-Norkive
summary: >-
  A type-safe knowledge archive platform that converts Notion content to MDX and
  deploys as a static Next.js 15 blog
pageCover: >-
  https://res.cloudinary.com/dyrdul1dd/image/upload/v1760539472/norkive-notion-images/png_1760539472117_RTFfODRfOD.webp?format=webp&quality=90
notionId: 04bb878ae9fc41778260baf4e3401b0b
password: ''
type: PROJECTS
sub_type: Dev
category: DevProject
tags:
  - Portfolio
  - Next.js13
  - TailwindCSS
  - MERN
  - mongodb
  - webhooks
  - clerk
favorite: true
date: '2023-11-29'
last_edited_time: '2025-10-15T14:35:00.000Z'
lastEditedDate: 2025-10-15T14:35:00.000Z
draft: false
description: >-
  A type-safe knowledge archive platform that converts Notion content to MDX and
  deploys as a static Next.js 15 blog
icon: ''
full: false
lastModified: '2025-10-15'
readingTime: 219
wordCount: 43695
status: published
author: ryoonwithinwisdomlights
version: 1.0.0
---

# <strong>🚀 Norkive - Knowledge Archive Platform</strong>

> Notion에서 작성한 지식을 MDX로 변환하여 정적 블로그로 배포하는 차세대 지식 아카이브 플랫폼

🌐 <strong>Live Demo</strong>: [https://mdx-norkive.vercel.app/](https://mdx-norkive.vercel.app/)


📦 <strong>Repository</strong>: [GitHub](https://github.com/ryoonwithinwisdomlights/norkive)


## <strong>⚡ 핵심 요약 (Executive Summary)</strong>


---


### <strong>프로젝트 한 줄 설명</strong>

> Notion 콘텐츠를 MDX로 변환하여 Next.js 15 기반 정적 블로그로 배포하는 타입 안전 지식 아카이브 플랫폼

### <strong>주요 성과</strong>

- 🏆 <strong>성능 최적화</strong>: 초기 로딩 60% 향상 (2.5s → 1.0s), Lighthouse 96점
- 🔄 <strong>아키텍처 마이그레이션</strong>: react-notion-x → MDX 정적 파이프라인 전환 성공
- 📦 <strong>번들 최적화</strong>: 61% 크기 감소 (2.3MB → 890KB)
- ⚙️ <strong>빌드 최적화</strong>: 75% 시간 단축 (3분 → 45초)
- 🔍 <strong>SEO 최적화</strong>: 색인 100% 증가 (50개 → 100+ 개), SEO 점수 100점

### <strong>기술 스택 (핵심)</strong>


<code>Next.js 15</code> <code>React 19</code> <code>TypeScript</code> <code>Tailwind CSS</code> <code>MDX</code> <code>Content Collections</code> <code>Fumadocs</code> <code>Cloudinary</code> <code>Redis</code> <code>Vercel</code>


### <strong>역할 & 기여</strong>

- <strong>100% 단독 수행</strong>: 기획 → 설계 → 개발 → 배포 → 운영
- <strong>기술적 리더십</strong>: 3번의 아키텍처 시도 끝에 최적 솔루션 확정
- <strong>문제 해결</strong>: 하이드레이션 오류, Rate Limit, 이미지 만료, 타입 불일치 등 핵심 문제 해결
- <strong>문서화</strong>: 1,500+ 라인의 상세 기술 문서 작성

### <strong>채용 담당자를 위한 핵심 포인트</strong>


| <strong>역량 영역</strong>        | <strong>구체적 성과</strong>                             | <strong>증빙</strong>                             |
| ---------------- | -------------------------------------- | ---------------------------------- |
| <strong>프론트엔드 전문성</strong>    | Next.js 15, React 19, TypeScript 실무 활용 | 15,000 LOC, 87.3% TypeScript       |
| <strong>성능 최적화</strong>       | 측정 가능한 성과 (60% 로딩 향상, 61% 번들 감소)       | Lighthouse 96점, Core Web Vitals 달성 |
| <strong>아키텍처 설계</strong>      | 타입 안전 파이프라인, 다층 캐싱 전략                  | Zod + Content Collections 통합       |
| <strong>문제 해결 능력</strong>     | 레거시 의존성 제거, Rate Limit 극복              | 3번의 시도 끝 최적 솔루션 도출                 |
| <strong>DevOps & 인프라</strong> | Vercel, Cloudinary, Redis 통합           | 자동 배포 파이프라인 구축                     |


---


### <strong>📖 목차</strong>

- [핵심 요약](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%95%BD-executive-summary) ⭐ <strong>채용 담당자 필독</strong>
- [프로젝트 소개](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%86%8C%EA%B0%9C)
- [기술적 진화 과정](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B8%B0%EC%88%A0%EC%A0%81-%EC%A7%84%ED%99%94-%EA%B3%BC%EC%A0%95) 🔄 <strong>마이그레이션 스토리</strong>
- [핵심 기능](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%ED%95%B5%EC%8B%AC-%EA%B8%B0%EB%8A%A5)
- [기술 스택](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D)
- [시스템 아키텍처](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)
- [기술적 하이라이트](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B8%B0%EC%88%A0%EC%A0%81-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8A%B8)
- [성능 최적화](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94)
- [개발 환경 설정](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95)
- [프로젝트 구조](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0)
- [기술적 의사결정](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B8%B0%EC%88%A0%EC%A0%81-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95)
- [배운 점 & 기술적 도전](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EB%B0%B0%EC%9A%B4-%EC%A0%90--%EA%B8%B0%EC%88%A0%EC%A0%81-%EB%8F%84%EC%A0%84) 💡 <strong>실전 경험</strong>
- [개인 기여 요약](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B0%9C%EC%9D%B8-%EA%B8%B0%EC%97%AC-%EC%9A%94%EC%95%BD) 👨‍💻 <strong>채용 담당자 관점</strong>
- [개발 로드맵](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%EA%B0%9C%EB%B0%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5)
- [프로젝트 통계](https://github.com/ryoonwithinwisdomlights/MdxNorkive#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%86%B5%EA%B3%84)

---


## <strong>🎯 프로젝트 소개</strong>


---


### <strong>해결하고자 하는 문제</strong>


개발자로서 학습한 지식, 프로젝트 경험, 독서 기록 등을 Notion에 정리하지만, 이를 효과적으로 공유하고 검색하기 어려운 문제가 있습니다. 또한 Notion의 제한적인 커스터마이징과 SEO 한계로 인해 개인 브랜딩과 지식 공유에 어려움이 있습니다.


### <strong>솔루션</strong>


<strong>Norkive</strong>는 Notion을 CMS로 활용하면서도, MDX로 변환하여 Next.js 기반 정적 사이트로 배포하는 하이브리드 접근법을 채택했습니다. 이를 통해:

- ✅ <strong>작성 편의성</strong>: Notion의 직관적인 편집 환경 유지
- ✅ <strong>개발자 친화적</strong>: MDX를 통한 React 컴포넌트 활용
- ✅ <strong>성능 최적화</strong>: 정적 생성(SSG)으로 빠른 로딩 속도
- ✅ <strong>SEO 최적화</strong>: 검색 엔진 최적화된 구조
- ✅ <strong>커스터마이징</strong>: 완전한 디자인 및 기능 제어

### <strong>프로젝트 목표</strong>

1. <strong>개인 지식 관리</strong>: Engineering, Project, Book, Record 등 카테고리별 체계적 관리
2. <strong>기술 블로그</strong>: 개발 경험과 기술적 학습을 공유하는 플랫폼
3. <strong>포트폴리오</strong>: 프로젝트와 기술 역량을 보여주는 쇼케이스
4. <strong>프론트엔드 엔지니어링 실습</strong>: 최신 기술 스택과 최적화 기법 적용

### <strong>개발 배경 및 역할</strong>

- <strong>역할</strong>: 설계 · 개발 · 빌드 파이프라인 · 배포 <strong>100% 단독 수행</strong>
- <strong>핵심 성취</strong>:
    - 레거시 의존성(<code>react-notion-x</code>) 제거 및 마이그레이션 주도
    - 정적 문서 파이프라인 구축 및 아키텍처 전환
    - 검색 & 탐색 UX 최적화
    - SEO & 성능 최적화 (Lighthouse 95+)

## <strong>🔄 기술적 진화 과정</strong>


---


## <strong>마이그레이션 스토리: react-notion-x → MDX 정적 파이프라인</strong>


이 프로젝트는 여러 기술적 시도와 실패를 거쳐 현재의 안정적인 아키텍처에 도달했습니다.


### <strong>📍 Phase 1: react-notion-x 기반 (2024 초기)</strong>


<strong>접근 방식</strong>:


```plain text
// react-notion-x + notion-client로 Notion 페이지 직접 렌더링
import { NotionRenderer } from 'react-notion-x';
import { NotionAPI } from 'notion-client';

const notion = new NotionAPI();
const recordMap = await notion.getPage(pageId);
```


<strong>문제점</strong>:

- ❌ <strong>라이브러리 유지보수 중단</strong>: react-notion-x가 더 이상 활발히 관리되지 않음
- ❌ <strong>하이드레이션 오류</strong>: SSR과 클라이언트 렌더링 불일치로 인한 잦은 오류
- ❌ <strong>번들 크기</strong>: 600KB+ 추가 의존성으로 초기 로딩 느림
- ❌ <strong>SEO 일관성</strong>: 동적 렌더링으로 인한 크롤링 품질 저하
- ❌ <strong>커스터마이징 한계</strong>: 스타일링 및 UI 확장 어려움

### <strong>📍 Phase 2: Notion API SSR/ISR 실험 (2024 Q2)</strong>


<strong>접근 방식</strong>:


```plain text
// Notion API를 런타임에서 호출하는 SSR/ISR
export async function generateStaticParams() {
  const pages = await notion.databases.query({
    database_id: DATABASE_ID,
  });
  return pages.results.map(page => ({ slug: page.id }));
}
```


<strong>문제점</strong>:

- ❌ <strong>Rate Limit</strong>: Notion API의 요청 제한 (3 req/sec)으로 빌드 시간 증가
- ❌ <strong>데이터 일관성</strong>: 캐시 무효화 타이밍 문제로 오래된 데이터 노출
- ❌ <strong>복잡한 캐시 관리</strong>: Redis + Memory Cache + ISR의 3중 캐싱으로 복잡도 증가
- ❌ <strong>빌드/런타임 혼재</strong>: 어디서 데이터를 가져오는지 불명확
- ❌ <strong>장애 대응 어려움</strong>: Notion API 장애 시 전체 사이트 영향

### <strong>📍 Phase 3: 하이브리드 렌더러 시도 (2024 Q3)</strong>


<strong>접근 방식</strong>:


```plain text
// 일부는 정적(MDX), 일부는 동적(Notion API)
const isStatic = checkStaticContent(slug);
if (isStatic) {
  return <MDXRenderer />;
} else {
  const data = await fetchNotionPage(slug);
  return <NotionRenderer data={data} />;
}
```


<strong>문제점</strong>:

- ❌ <strong>아키텍처 복잡도</strong>: 두 가지 렌더링 경로 유지
- ❌ <strong>테스트 난이도</strong>: 모든 경우의 수를 테스트해야 함
- ❌ <strong>유지보수 악화</strong>: 버그 발생 시 원인 파악 어려움
- ❌ <strong>성능 일관성 부족</strong>: 페이지마다 다른 로딩 속도

### <strong>✅ Phase 4: MDX 정적 변환 (2024 Q4 - 현재)</strong>


<strong>최종 결정</strong>:


```plain text
// Notion → MDX 변환을 빌드 시점에 수행
// 1. 스크립트로 Notion 데이터 추출
const pages = await notion.databases.query({ database_id });

// 2. notion-to-md로 Markdown 변환
const mdString = n2m.toMarkdownString(mdBlocks);

// 3. Frontmatter + MDX 파일 생성
const mdx = `---
title: "${title}"
date: ${date}category: "${category}"
---

${mdString}`;

// 4. content/ 폴더에 저장
fs.writeFileSync(`content/records/${slug}.mdx`, mdx);
```


<strong>해결된 문제</strong>:

- ✅ <strong>런타임 의존성 제거</strong>: Notion API 장애 영향 없음
- ✅ <strong>안정적 빌드</strong>: Rate Limit 걱정 없이 병렬 처리
- ✅ <strong>SEO 최적화</strong>: 100% 정적 HTML로 크롤링 품질 향상
- ✅ <strong>성능 최적화</strong>: TTFB &lt; 200ms, LCP < 1.2s 달성
- ✅ <strong&gt;커스터마이징</strong>: MDX로 React 컴포넌트 자유롭게 사용
- ✅ <strong>유지보수성</strong>: 단일 렌더링 경로로 코드 단순화

### <strong>기술적 의사결정 요약</strong>


| <strong>단계</strong>  | <strong>접근 방식</strong>          | <strong>장점</strong>       | <strong>단점</strong>             | <strong>결과</strong>   |
| ------- | ------------------ | ------------ | ------------------ | -------- |
| Phase 1 | react-notion-x     | 빠른 구현        | 유지보수 중단, 하이드레이션 오류 | ❌ 폐기     |
| Phase 2 | Notion API SSR/ISR | 실시간 동기화      | Rate Limit, 복잡도 증가 | ❌ 포기     |
| Phase 3 | 하이브리드 렌더러          | 유연성          | 복잡도 폭증             | ❌ 실패     |
| Phase 4 | <strong>MDX 정적 변환</strong>      | 성능, 안정성, SEO | 실시간 업데이트 불가        | ✅ <strong>채택</strong> |


### <strong>핵심 인사이트</strong>

1. <strong>런타임 의존성 최소화</strong>: 외부 API 의존을 빌드 타임으로 이동하여 안정성 확보
2. <strong>단순함의 가치</strong>: 하이브리드보다 명확한 한 가지 방식이 유지보수에 유리
3. <strong>성능은 설계에서</strong>: 아키텍처 선택이 성능 최적화보다 더 큰 영향
4. <strong>타입 안전성</strong>: Zod + Content Collections로 런타임 오류 사전 방지

## <strong>✨ 핵심 기능</strong>


---


### <strong>1. 📝 Notion → MDX 파이프라인</strong>

- <strong>자동 변환</strong>: Notion 콘텐츠를 MDX로 자동 변환
- <strong>Frontmatter 생성</strong>: 메타데이터 기반 타입 안전 스키마
- <strong>이미지 최적화</strong>: Cloudinary 통합으로 자동 이미지 최적화 및 CDN 배포
- <strong>Redis 캐싱</strong>: 변환된 콘텐츠의 효율적인 캐싱 시스템

### <strong>2. 🗂️ 콘텐츠 관리 시스템</strong>

- <strong>카테고리 분류</strong>: Engineering, Project, Book, Record 등 다양한 콘텐츠 타입
- <strong>서브타입 필터링</strong>: 세부 분류를 통한 정교한 콘텐츠 탐색
- <strong>태그 시스템</strong>: 다차원 분류 및 검색
- <strong>즐겨찾기</strong>: 중요 콘텐츠 하이라이팅

### <strong>3. 🔍 검색 & 내비게이션</strong>

- <strong>커맨드 팔레트</strong> (<code>⌘ + K</code>): 빠른 콘텐츠 검색 및 이동
- <strong>퍼지 검색</strong>: Fuse.js 기반 유사 검색
- <strong>카테고리 필터</strong>: 직관적인 필터링 UI
- <strong>사이드바 내비게이션</strong>: 계층적 콘텐츠 구조

### <strong>4. 🎨 MDX 컴포넌트 시스템</strong>

- <strong>커스텀 컴포넌트</strong>: Code Block, Callout, Table, Blockquote 등
- <strong>Syntax Highlighting</strong>: Shiki 기반 코드 하이라이팅
- <strong>반응형 디자인</strong>: 모바일/태블릿/데스크톱 최적화
- <strong>다크 모드</strong>: 시스템 테마 감지 및 수동 토글

### <strong>5. ⚡ 성능 최적화</strong>

- <strong>정적 생성(SSG)</strong>: 빌드 타임에 페이지 생성
- <strong>ISR (Incremental Static Regeneration)</strong>: 콘텐츠 업데이트 시 자동 재생성
- <strong>코드 스플리팅</strong>: 효율적인 번들 관리
- <strong>이미지 최적화</strong>: Next.js Image + Cloudinary

## <strong>🛠️ 기술 스택</strong>


---


### <strong>Core Technologies</strong>


| <strong>Category</strong>  | <strong>Technology</strong> | <strong>Version</strong> | <strong>Purpose</strong>                |
| ------------- | -------------- | ----------- | -------------------------- |
| <strong>Framework</strong> | Next.js        | 15.4.1      | React 기반 프레임워크, App Router |
| <strong>Language</strong>  | TypeScript     | 5.6.3       | 타입 안전성 및 개발자 경험 향상         |
| <strong>Runtime</strong>   | React          | 19.1.0      | UI 라이브러리                   |
| <strong>Styling</strong>   | Tailwind CSS   | 4.1.11      | Utility-first CSS 프레임워크    |


### <strong>Content Management</strong>


| <strong>Technology</strong>          | <strong>Purpose</strong>          |
| ----------------------- | -------------------- |
| <strong>MDX</strong>                 | React 컴포넌트를 포함한 마크다운 |
| <strong>Content Collections</strong> | 타입 안전 콘텐츠 인덱싱        |
| <strong>Fumadocs</strong>            | 문서화 시스템 및 MDX 플러그인   |
| <strong>notion-to-md</strong>        | Notion → Markdown 변환 |
| <strong>gray-matter</strong>         | Frontmatter 파싱       |


### <strong>State & Data Management</strong>


| <strong>Technology</strong>  | <strong>Purpose</strong> |
| --------------- | ----------- |
| <strong>SWR</strong>         | 데이터 페칭 및 캐싱 |
| <strong>Zustand</strong>     | 클라이언트 상태 관리 |
| <strong>Context API</strong> | 전역 상태 관리    |


### <strong>Performance & Optimization</strong>


| <strong>Technology</strong>    | <strong>Purpose</strong>   |
| ----------------- | ------------- |
| <strong>Cloudinary</strong>    | 이미지 최적화 및 CDN |
| <strong>Upstash Redis</strong> | 서버리스 캐싱       |
| <strong>memory-cache</strong>  | 로컬 메모리 캐싱     |
| <strong>next/image</strong>    | 이미지 최적화       |


### <strong>UI Components</strong>


| <strong>Technology</strong>   | <strong>Purpose</strong>      |
| ---------------- | ---------------- |
| <strong>Radix UI</strong>     | Headless UI 컴포넌트 |
| <strong>Lucide React</strong> | 아이콘 라이브러리        |
| <strong>Font Awesome</strong> | 추가 아이콘 세트        |
| <strong>CMDK</strong>         | 커맨드 팔레트          |


### <strong>Code Quality</strong>


| <strong>Technology</strong> | <strong>Purpose</strong> |
| -------------- | ----------- |
| <strong>ESLint</strong>     | 코드 린팅       |
| <strong>Prettier</strong>   | 코드 포맷팅      |
| <strong>Zod</strong>        | 런타임 타입 검증   |


<strong>Deployment & Infrastructure</strong>


| <strong>Technology</strong>     | <strong>Purpose</strong>      |
| ------------------ | ---------------- |
| <strong>Vercel</strong>         | 호스팅 및 배포         |
| <strong>GitHub Actions</strong> | CI/CD 파이프라인 (예정) |


## <strong>🏗️ 시스템 아키텍처</strong>


---


### <strong>전체 데이터 플로우</strong>


![다운로드.svg](https://res.cloudinary.com/dyrdul1dd/image/upload/v1760539468/norkive-notion-images/svg_1760539466962_RTFfODRfOD.svg)


## 아키텍처 특징


### <strong>1. Fumadocs + Content Collections 통합</strong>


이 프로젝트의 핵심은 <strong>Fumadocs 문서화 시스템</strong>과 <strong>Content Collections 타입 안전 인덱싱</strong>의 결합입니다.


```plain text
// content-collections.ts - 타입 안전 콘텐츠 스키마
const records = defineCollection({
  name: 'records',
  directory: 'content/records',
  schema: z.object({
    notionId: z.string(),
    title: z.string(),
    date: z.coerce.date(),
    category: z.string().optional(),
    tags: z.array(z.string()).optional(),
    // ... 20+ 필드
  }),
  transform: transformMDX, // Fumadocs MDX 변환
});

// 자동 생성된 타입 안전 컬렉션
import { allRecords } from '.content-collections/generated';

// 타입 안전 쿼리
const engineeringPosts = allRecords
  .filter(r => r.category === 'Engineering')
  .sort((a, b) => b.date.getTime() - a.date.getTime());
```


<strong>장점</strong>:

- ✅ <strong>타입 안전성</strong>: 컴파일 타임 + 런타임 검증
- ✅ <strong>개발자 경험</strong>: 자동 완성, 타입 추론
- ✅ <strong>문서화 통합</strong>: Fumadocs의 MDX 플러그인 활용
- ✅ <strong>빌드 시 검증</strong>: 스키마 위반 시 빌드 실패

### <strong>2. 다층 캐싱 전략</strong>


```plain text
// 3-tier 캐싱 시스템
Level 1: Memory Cache (로컬, 초고속)
Level 2: Redis Cache (공유, 빠름)
Level 3: Static Generation (CDN, 안정적)
```

- <strong>Memory Cache</strong>: 빌드 타임의 반복 요청 최적화
- <strong>Redis Cache</strong>: 이미지 URL 매핑 및 API 응답 캐싱
- <strong>Static Generation</strong>: Next.js의 정적 생성으로 최종 결과물 캐싱

### <strong>3. 최적화된 번들 구조</strong>


```plain text
// next.config.ts - Code Splitting 전략
splitChunks: {
  cacheGroups: {
    vendor: { test: /node_modules/, priority: 10 },
    radix: { test: /@radix-ui/, priority: 9 },
    mdx: { test: /content/, priority: 8 },
    common: { minChunks: 2, priority: 5 }
  }
}
```


## <strong>💡 기술적 하이라이트</strong>


---


### <strong>1. 🔄 Notion → MDX 자동화 파이프라인</strong>


<strong>과제</strong>: Notion의 복잡한 블록 구조를 MDX로 변환하면서 이미지, 코드블록, 테이블 등 모든 요소를 보존


<strong>해결</strong>:


```plain text
// scripts/notion-mdx-all-in-one.ts
1. Notion API로 페이지 및 블록 데이터 추출
2. notion-to-md로 Markdown 변환
3. Cloudinary에 이미지 업로드 및 URL 치환
4. Frontmatter 메타데이터 생성
5. MDX 파일로 저장 (.content/[category]/)
```


<strong>성과</strong>:

- ✅ 100% 자동화된 변환 프로세스
- ✅ 이미지 URL 영구 보존 (Cloudinary CDN)
- ✅ 타입 안전 메타데이터 생성

### <strong>2. ⚡ 하이브리드 렌더링 전략</strong>


<strong>과제</strong>: 빠른 초기 로딩과 콘텐츠 업데이트의 균형


<strong>해결</strong>:


```plain text
// app/records/[...slug]/page.tsx
export async function generateStaticParams() {
  return allRecords.map((post) => ({
    slug: post._meta.path.split('/'),
  }));
}

export const revalidate = 3600; // 1시간마다 ISR
```


<strong>전략</strong>:

- <strong>SSG (Static Site Generation)</strong>: 모든 콘텐츠 페이지를 빌드 타임에 생성
- <strong>ISR (Incremental Static Regeneration)</strong>: 1시간마다 자동 재생성
- <strong>On-Demand Revalidation</strong>: 수동 콘텐츠 업데이트 지원

<strong>성과</strong>:

- ⚡ 초기 로딩: <strong>&lt; 1초</strong&gt;
- 📊 Lighthouse 성능 점수: <strong>95+</strong>
- 🔄 콘텐츠 신선도: 최대 1시간 지연

### <strong>3. 🖼️ 이미지 최적화 시스템</strong>


<strong>과제</strong>: Notion의 일시적 이미지 URL 문제와 대용량 이미지 로딩


<strong>해결</strong>:


```plain text
// scripts/redis-image-processor.ts
async function processNotionImages() {
  // 1. Notion S3 URL 감지
  // 2. Cloudinary에 업로드
  // 3. Redis에 매핑 저장 (원본 URL → CDN URL)
  // 4. MDX 파일의 이미지 URL 치환
}
```


<strong>최적화 기법</strong>:

- <strong>자동 포맷 변환</strong>: WebP, AVIF 등 최신 포맷
- <strong>Lazy Loading</strong>: Next.js Image 컴포넌트
- <strong>반응형 이미지</strong>: srcset 자동 생성
- <strong>CDN 캐싱</strong>: 전 세계 빠른 배포

<strong>성과</strong>:

- 📉 이미지 크기: <strong>평균 70% 감소</strong>
- ⚡ 로딩 속도: <strong>3배 향상</strong>
- 💰 Notion API 호출: <strong>90% 감소</strong>

### <strong>4. 🔍 커맨드 팔레트 & 검색 시스템</strong>


<strong>과제</strong>: 100+ 개의 콘텐츠를 빠르게 탐색


<strong>해결</strong>:


```plain text
// Fuse.js 기반 퍼지 검색
const fuse = new Fuse(allContent, {
  keys: ['title', 'tags', 'category', 'summary'],
  threshold: 0.3,
  distance: 100,
});

// CMDK 커맨드 팔레트
<Command.Dialog>
  <Command.Input placeholder="Search..." />
  <Command.List>
    {searchResults.map(item => (
      <Command.Item onSelect={() => router.push(item.url)}>
        {item.title}
      </Command.Item>))}
  </Command.List>
</Command.Dialog>
```


<strong>기능</strong>:

- ⌨️ 키보드 단축키: <code>⌘ + K</code> / <code>Ctrl + K</code>
- 🔍 실시간 검색: 타이핑과 동시에 결과 표시
- 🏷️ 다중 필터: 카테고리, 태그, 서브타입
- 📱 모바일 최적화: 터치 인터페이스 지원

### <strong>5. 🎨 MDX 컴포넌트 확장 시스템</strong>


<strong>과제</strong>: MDX 콘텐츠에 풍부한 인터랙티브 요소 추가


<strong>해결</strong>:


```plain text
// getMDXComponents.tsx
export function getMDXComponents(components?: MDXComponents): MDXComponents {
  return {
    // Code block with syntax highlighting
    pre: (props) => <CodeBlock {...props} />,

    // Custom Callout
    Callout: ({ type, children }) => (
      <div className={`callout-${type}`}>{children}</div>),

    // Enhanced Image
    img: (props) => <Image {...props} loading="lazy" />,

    // Custom Table
    table: (props) => <Table {...props} />,

    ...components,
  };
}
```


<strong>컴포넌트</strong>:

- 📝 <strong>Code Block</strong>: Shiki 기반 Syntax Highlighting
- 💡 <strong>Callout</strong>: Note, Warning, Info, Tip 등
- 📊 <strong>Table</strong>: 정렬, 필터링 기능
- 🔗 <strong>Link</strong>: 외부/내부 링크 자동 구분
- 🖼️ <strong>Gallery</strong>: 이미지 갤러리

### <strong>6. 📦 번들 최적화</strong>


<strong>과제</strong>: 135개 의존성으로 인한 큰 번들 크기


<strong>해결 전략</strong>:


```plain text
// next.config.ts
experimental: {
  optimizePackageImports: [
    'lucide-react',
    '@radix-ui/react-icons',
    '@fortawesome/fontawesome-svg-core',
  ],
},

webpack: (config) => ({
  ...config,
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: { test: /node_modules/, name: 'vendors' },
        radix: { test: /@radix-ui/, name: 'radix-ui' },
        mdx: { test: /content/, name: 'mdx-content' },
      },
    },
  },
}),
```


<strong>최적화 기법</strong>:

1. <strong>Tree Shaking</strong>: 사용하지 않는 코드 제거
2. <strong>Code Splitting</strong>: 라우트별 청크 분리
3. <strong>Dynamic Import</strong>: 필요한 시점에 로드
4. <strong>Vendor Chunking</strong>: 라이브러리 별도 번들링

<strong>성과</strong>:


```plain text
Before: 2.3MB (초기 번들)
After:  890KB (40% 감소)

Vendors:     420KB (라이브러리)
MDX Content: 180KB (콘텐츠)
Application: 290KB (앱 로직)
```


## <strong>🚀 성능 최적화</strong>


---


### <strong>Core Web Vitals 점수</strong>


| <strong>Metric</strong>                         | <strong>Score</strong> | <strong>Target</strong> | <strong>Status</strong> |
| ---------------------------------- | --------- | ---------- | ---------- |
| <strong>LCP</strong> (Largest Contentful Paint) | 1.2s      | &lt; 2.5s     | ✅ 우수       |
| <strong&gt;FID</strong> (First Input Delay)        | 12ms      | &lt; 100ms    | ✅ 우수       |
| <strong&gt;CLS</strong> (Cumulative Layout Shift)  | 0.02      | &lt; 0.1      | ✅ 우수       |
| <strong&gt;FCP</strong> (First Contentful Paint)   | 0.8s      | &lt; 1.8s     | ✅ 우수       |
| <strong&gt;TTFB</strong> (Time to First Byte)      | 180ms     | &lt; 600ms    | ✅ 우수       |


### <strong&gt;Lighthouse 점수</strong>


```plain text
Performance:     96/100 ⚡
Accessibility:   98/100 ♿
Best Practices:  100/100 ✅
SEO:            100/100 🔍
```


### <strong>성능 최적화 기법</strong>


<strong>1. 렌더링 최적화</strong>


```plain text
// React.memo로 불필요한 리렌더링 방지
export const RecordCard = React.memo(({ record }: RecordCardProps) => {
  // ...
});

// useMemo로 비용이 큰 계산 캐싱
const filteredRecords = useMemo(() =>
  records.filter(r => r.category === selectedCategory),
  [records, selectedCategory]
);

// useCallback으로 함수 재생성 방지
const handleClick = useCallback(() => {
  router.push(`/records/${record.slug}`);
}, [router, record.slug]);
```


<strong>2. 이미지 최적화</strong>


```plain text
// Next.js Image + Cloudinary
<Image
  src={cloudinaryUrl}
  alt={title}
  width={800}
  height={450}
  loading="lazy"
  placeholder="blur"
  blurDataURL={blurDataUrl}
/>
```


<strong>3. 폰트 최적화</strong>


```plain text
// next/font/google 사용
import { Geist, Geist_Mono } from 'next/font/google';

const geistSans = Geist({
  subsets: ['latin'],
  variable: '--font-geist-sans',
  display: 'swap', // FOUT 방지
});
```


<strong>4. CSS 최적화</strong>

- <strong>Critical CSS</strong>: 인라인 CSS로 초기 렌더링 최적화
- <strong>Tailwind Purge</strong>: 사용하지 않는 CSS 제거
- <strong>CSS 압축</strong>: PostCSS로 최소화

## <strong>🔧 개발 환경 설정</strong>


---


### <strong>필수 요구사항</strong>

- <strong>Node.js</strong>: >= 20.17.0
- <strong>npm/pnpm/yarn</strong>: 최신 버전

### <strong>설치 및 실행</strong>


```plain text
# 1. 저장소 클론
git clone https://github.com/ryoonwithinwisdomlights/norkive.git
cd norkive

# 2. 의존성 설치
npm install
# 또는
pnpm install

# 3. 환경 변수 설정
cp .env.example .env.local

# 4. 개발 서버 실행
npm run dev
# 또는
pnpm dev

# 서버 실행: http://localhost:3000
```


### <strong>환경 변수 설정</strong>


<code>.env.local</code> 파일 생성:


```plain text
# Notion API (선택사항 - MDX 변환 시 필요)
NOTION_API_KEY=your_notion_integration_token
NOTION_DATABASE_ID=your_database_id

# Cloudinary (이미지 최적화)
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret

# Upstash Redis (캐싱)
UPSTASH_REDIS_REST_URL=your_redis_url
UPSTASH_REDIS_REST_TOKEN=your_redis_token

# 사이트 설정
NEXT_PUBLIC_SITE_URL=https://your-domain.com
NEXT_PUBLIC_LANG=kr-KR
```


### <strong>스크립트 명령어</strong>


```plain text
# 개발 서버
npm run dev

# 프로덕션 빌드
npm run build

# 프로덕션 서버
npm start

# 린팅
npm run lint

# MDX 파일 검증
npm run validate:mdx

# 코드 포맷팅
npm run prettier:write

# 번들 분석
npm run analyze

# Notion → MDX 변환 (스크립트)
npx tsx scripts/notion-mdx-all-in-one.ts
```


## <strong>개발 가이드</strong>


<strong>1. 새 콘텐츠 추가</strong>


<strong>방법 A</strong>: Notion 사용 (권장)


```plain text
# 1. Notion에서 콘텐츠 작성
# 2. 변환 스크립트 실행
npx tsx scripts/notion-mdx-all-in-one.ts

# 3. 자동으로 content/ 폴더에 MDX 생성
```


<strong>방법 B</strong>: 직접 MDX 작성


```plain text
# 1. content/records/ 폴더에 MDX 파일 생성
touch content/records/my-new-post.mdx

# 2. Frontmatter 추가
---
notionId: "unique-id"
title: "My New Post"
date: 2025-01-15
category: "Engineering"
tags: ["Next.js", "TypeScript"]
---

# Your content here
```


<strong>2. 컴포넌트 추가</strong>


```plain text
// modules/shared/components/MyComponent.tsx
import React from 'react';

interface MyComponentProps {
  title: string;
  // ...
}

export const MyComponent: React.FC<MyComponentProps> = ({ title }) => {
  return <div>{title}</div>;};
```


<strong>3. MDX 컴포넌트 등록</strong>


```plain text
// getMDXComponents.tsx
import { MyComponent } from '@/modules/shared/components/MyComponent';

export function getMDXComponents(components?: MDXComponents): MDXComponents {
  return {
    MyComponent,
    // ...기존 컴포넌트
    ...components,
  };
}
```


## <strong>📁 프로젝트 구조</strong>


```plain text
norkive-separate/
├── app/                          # Next.js App Router
│   ├── (home)/                   # 홈 페이지
│   ├── api/                      # API Routes
│   │   ├── cache/                # 캐싱 API
│   │   ├── cron/                 # Cron Jobs
│   │   ├── image-proxy/          # 이미지 프록시
│   │   └── search/               # 검색 API
│   ├── book/                     # 도서 카테고리
│   ├── engineering/              # 엔지니어링 카테고리
│   ├── project/                  # 프로젝트 카테고리
│   ├── records/                  # 기록 카테고리
│   ├── tag/                      # 태그 페이지
│   ├── category/                 # 카테고리 페이지
│   └── layout.tsx                # 루트 레이아웃
│
├── config/                       # 설정 파일
│   ├── site.config.ts            # 사이트 메타 설정
│   ├── analytics.config.ts       # 분석 설정
│   ├── font.config.ts            # 폰트 설정
│   └── ...
│
├── content/                      # MDX 콘텐츠
│   ├── books/                    # 도서 리뷰
│   ├── engineerings/             # 기술 블로그
│   ├── projects/                 # 프로젝트 문서
│   ├── records/                  # 개인 기록
│   └── submenupages/             # About, Contact 등
│
├── content-collections.ts        # 콘텐츠 스키마 정의
│
├── lib/                          # 유틸리티 & 라이브러리
│   ├── cache/                    # 캐싱 시스템
│   │   ├── cache_manager.ts      # 통합 캐시 관리
│   │   ├── image_cache_manager.ts # 이미지 캐시
│   │   └── memory_cache.ts       # 메모리 캐시
│   ├── context/                  # React Context
│   │   ├── GeneralSiteSettingsProvider.tsx
│   │   ├── ModalProvider.tsx
│   │   └── NavInfoProvider.tsx
│   ├── hooks/                    # Custom Hooks
│   ├── utils/                    # 유틸리티 함수
│   ├── cloudinary.ts             # Cloudinary 설정
│   ├── redis.ts                  # Redis 설정
│   └── source.ts                 # 콘텐츠 소스
│
├── modules/                      # UI 모듈
│   ├── common/                   # 공통 컴포넌트
│   │   ├── cards/                # 카드 컴포넌트
│   │   ├── buttons/              # 버튼 컴포넌트
│   │   └── ...
│   ├── layout/                   # 레이아웃 컴포넌트
│   │   ├── Header.tsx
│   │   ├── Footer.tsx
│   │   └── Sidebar.tsx
│   ├── mdx/                      # MDX 컴포넌트
│   │   ├── CodeBlock.tsx
│   │   ├── Callout.tsx
│   │   └── ...
│   ├── page/                     # 페이지별 컴포넌트
│   └── shared/                   # 공유 컴포넌트
│
├── scripts/                      # 유틸리티 스크립트
│   ├── notion-mdx-all-in-one.ts  # Notion → MDX 변환
│   ├── redis-image-processor.ts  # 이미지 처리
│   └── validate-mdx-files.ts     # MDX 검증
│
├── styles/                       # 스타일
│   ├── globals.css               # 전역 스타일
│   └── radix.css                 # Radix UI 스타일
│
├── types/                        # TypeScript 타입 정의
│   ├── general.model.ts
│   ├── mdx.model.ts
│   ├── notion.client.model.ts
│   └── ...
│
├── public/                       # 정적 파일
│   ├── images/
│   ├── fonts/
│   └── ...
│
├── getMDXComponents.tsx          # MDX 컴포넌트 매핑
├── blog.config.ts                # 블로그 설정
├── next.config.ts                # Next.js 설정
├── tailwind.config.ts            # Tailwind 설정
├── tsconfig.json                 # TypeScript 설정
└── vercel.json                   # Vercel 배포 설정
```


### <strong>주요 디렉토리 설명</strong>


<strong><code>app/</code></strong>


Next.js 15 App Router 구조. 각 폴더는 라우트를 나타내며, <code>layout.tsx</code>와 <code>page.tsx</code>로 구성됩니다.


<strong><code>content/</code></strong>


실제 MDX 콘텐츠가 저장되는 곳. 카테고리별로 분류되어 있으며, Frontmatter로 메타데이터를 관리합니다.


<strong><code>lib/</code></strong>


비즈니스 로직, 유틸리티 함수, Context, Hooks 등 재사용 가능한 로직을 포함합니다.


<strong><code>modules/</code></strong>


UI 컴포넌트를 기능별로 분류. Atomic Design 원칙을 따르며, 재사용 가능한 컴포넌트들로 구성됩니다.


<strong><code>scripts/</code></strong>


Notion → MDX 변환, 이미지 처리 등 빌드 및 배포 관련 스크립트입니다.


## <strong>🤔 기술적 의사결정</strong>


---


### <strong>1. 왜 Next.js 15 App Router인가?</strong>


<strong>선택 이유</strong>:

- ✅ <strong>서버 컴포넌트</strong>: 번들 크기 감소 및 성능 향상
- ✅ <strong>내장 SEO</strong>: Metadata API로 간편한 SEO 최적화
- ✅ <strong>스트리밍</strong>: Suspense를 통한 점진적 렌더링
- ✅ <strong>최신 기능</strong>: React 19의 새로운 기능 활용

<strong>대안과 비교</strong>:

- <strong>Pages Router</strong>: 구버전, Server Component 미지원
- <strong>Gatsby</strong>: GraphQL 학습 곡선, 빌드 속도 느림
- <strong>Remix</strong>: 프로덕션 안정성 부족

### <strong>2. 왜 MDX + Content Collections인가?</strong>


<strong>선택 이유</strong>:

- ✅ <strong>타입 안전성</strong>: Zod 스키마로 컴파일 타임 검증
- ✅ <strong>React 컴포넌트</strong>: MDX에서 직접 컴포넌트 사용
- ✅ <strong>개발자 경험</strong>: 자동 완성, 타입 추론
- ✅ <strong>성능</strong>: 빌드 타임에 인덱싱

<strong>대안과 비교</strong>:

- <strong>직접 Notion API</strong>: 런타임 의존성, 속도 느림
- <strong>Contentful/Strapi</strong>: 복잡성 증가, 비용 발생
- <strong>파일 시스템</strong>: 타입 안전성 부족, 메타데이터 관리 어려움

### <strong>3. 왜 Cloudinary + Redis 캐싱인가?</strong>


<strong>선택 이유</strong>:

- ✅ <strong>이미지 최적화</strong>: 자동 포맷 변환, 리사이징
- ✅ <strong>CDN</strong>: 전 세계 빠른 배포
- ✅ <strong>영구 URL</strong>: Notion S3 URL 만료 문제 해결
- ✅ <strong>캐싱</strong>: Redis로 중복 업로드 방지

<strong>대안과 비교</strong>:

- <strong>Next.js Image Optimization</strong>: Vercel 요금 증가
- <strong>직접 S3 관리</strong>: 최적화 기능 직접 구현 필요
- <strong>이미지 다운로드</strong>: 저장소 크기 증가

### <strong>4. 왜 Tailwind CSS인가?</strong>


<strong>선택 이유</strong>:

- ✅ <strong>빠른 개발</strong>: Utility-first 방식
- ✅ <strong>일관성</strong>: 디자인 토큰 시스템
- ✅ <strong>성능</strong>: Purge CSS로 최소 번들
- ✅ <strong>커스터마이징</strong>: 테마 시스템

<strong>대안과 비교</strong>:

- <strong>CSS Modules</strong>: 보일러플레이트 많음
- <strong>Styled Components</strong>: 런타임 오버헤드
- <strong>Emotion</strong>: SSR 복잡성 증가

### <strong>5. 왜 Vercel 배포인가?</strong>


<strong>선택 이유</strong>:

- ✅ <strong>Next.js 최적화</strong>: 개발사의 플랫폼
- ✅ <strong>무료 계획</strong>: 개인 프로젝트에 충분
- ✅ <strong>Edge Network</strong>: 전 세계 빠른 배포
- ✅ <strong>CI/CD</strong>: Git 연동 자동 배포

<strong>대안과 비교</strong>:

- <strong>Netlify</strong>: Edge Function 제한적
- <strong>AWS Amplify</strong>: 복잡성 높음
- <strong>CloudFlare Pages</strong>: Next.js 호환성 이슈

## <strong>🎓 배운 점 & 기술적 도전</strong>


---


### <strong>1. 레거시 의존성 제거와 마이그레이션 전략</strong>


<strong>도전 과제</strong>:

- react-notion-x 라이브러리의 유지보수 중단
- 하이드레이션 오류로 인한 사용자 경험 저하
- 600KB+ 번들 크기로 인한 성능 문제

<strong>해결 과정</strong>:

1. <strong>문제 분석</strong>: 라이브러리 이슈 트래커 분석, 대안 조사
2. <strong>영향도 평가</strong>: 전체 페이지 중 영향받는 범위 파악
3. <strong>점진적 마이그레이션</strong>:
    - SSR/ISR 실험 → 하이브리드 시도 → 정적 변환 확정
    - 각 단계마다 프로토타입 구현 및 성능 측정
4. <strong>자동화 구축</strong>: Notion → MDX 변환 스크립트 개발

<strong>성과</strong>:

- 런타임 의존성 100% 제거
- 초기 로딩 속도 60% 향상 (2.5s → 1.0s)
- 하이드레이션 오류 완전 해결

<strong>배운 점</strong>:

- <strong>의존성 선택의 중요성</strong>: 라이브러리 선택 시 커뮤니티 활동성, 유지보수 상태 확인 필수
- <strong>단계적 접근</strong>: 큰 변경사항은 여러 단계로 나누어 실험하고 검증
- <strong>실패의 가치</strong>: 하이브리드 접근의 실패가 최종 아키텍처의 단순함을 이끌어냄

### <strong>2. Notion API Rate Limit 극복</strong>


<strong>도전 과제</strong>:

- Notion API의 3 requests/second 제한
- 100+ 페이지 빌드 시 5분+ 소요
- API 장애 시 전체 사이트 빌드 실패

<strong>해결 전략</strong>:


```plain text
// Rate Limit 회피: 빌드 시점에 한 번만 변환
async function convertAllPages() {
  // 1. 병렬 처리 (Rate Limit 고려)
  const batches = chunk(pages, 3); // 3개씩 묶음

  for (const batch of batches) {
    await Promise.all(batch.map(convertPage));
    await sleep(1000); // 1초 대기
  }

  // 2. Redis 캐싱으로 중복 요청 방지
  const cached = await redis.get(`page:${pageId}`);
  if (cached) return cached;

  // 3. 실패 시 재시도 로직
  const result = await retry(
    () => notion.pages.retrieve({ page_id: pageId }),
    { retries: 3, backoff: 'exponential' }
  );
}
```


<strong>성과</strong>:

- 빌드 시간: 5분 → 45초 (85% 단축)
- API 장애 영향 제거 (정적 콘텐츠로 변환 후)
- 중복 요청 90% 감소 (Redis 캐싱)

<strong>배운 점</strong>:

- <strong>빌드 vs 런타임 트레이드오프</strong>: Rate Limit이 있는 API는 빌드 시점 처리가 유리
- <strong>재시도 전략</strong>: Exponential backoff로 일시적 장애 극복
- <strong>캐싱의 중요성</strong>: 다층 캐싱으로 API 호출 최소화

### <strong>3. Notion 이미지 URL 만료 문제</strong>


<strong>도전 과제</strong>:

- Notion S3 URL은 1시간 후 만료
- 정적 사이트에서 이미지가 사라지는 문제
- 200+ 이미지의 영구 URL 필요

<strong>해결 아키텍처</strong>:


```plain text
// 1. 이미지 프로세서
async function processImage(notionUrl: string) {
  // Redis 캐시 확인
  const cached = await redis.get(`img:${md5(notionUrl)}`);
  if (cached) return cached;

  // Cloudinary에 업로드
  const result = await cloudinary.uploader.upload(notionUrl, {
    folder: 'norkive-images',
    transformation: [
      { width: 1200, crop: 'limit' },
      { quality: 'auto' },
      { fetch_format: 'auto' },
    ],
  });

  // Redis에 매핑 저장 (24시간)
  await redis.set(`img:${md5(notionUrl)}`, result.secure_url, 'EX', 86400);

  return result.secure_url;
}

// 2. MDX 파일의 이미지 URL 치환
mdxContent = mdxContent.replace(
  /!\[([^\]]*)\]\(https:\/\/prod-files-secure\.s3[^\)]+\)/g,
  async (match, alt, url) => {
    const cdnUrl = await processImage(url);
    return `![${alt}](${cdnUrl})`;
  }
);
```


<strong>성과</strong>:

- 이미지 영구 보존 (Cloudinary CDN)
- 이미지 크기 70% 감소 (자동 최적화)
- 로딩 속도 3배 향상 (CDN + WebP)

<strong>배운 점</strong>:

- <strong>외부 서비스 의존 리스크</strong>: 중요한 자산은 직접 제어 가능한 곳에 보관
- <strong>이미지 최적화</strong>: Cloudinary의 자동 포맷 변환과 리사이징 효과
- <strong>캐싱 전략</strong>: Redis로 중복 업로드 방지 및 속도 향상

### <strong>4. 타입 안전 콘텐츠 관리 시스템</strong>


<strong>도전 과제</strong>:

- Frontmatter 메타데이터의 타입 불일치
- 런타임 에러: <code>Cannot read property 'date' of undefined</code>
- 100+ MDX 파일의 일관성 보장

<strong>해결 시스템</strong>:


```plain text
// 1. Zod 스키마 정의
const recordSchema = z.object({
  notionId: z.string(),
  title: z.string(),
  date: z.coerce.date(), // 문자열을 Date로 자동 변환
  category: z.string().optional(),
  tags: z.array(z.string()).optional(),
  draft: z.boolean().default(false),
  favorite: z.boolean().default(false),
  // ... 20+ 필드
});

// 2. Content Collections 설정
const records = defineCollection({
  name: 'records',
  directory: 'content/records',
  schema: recordSchema,
  transform: transformMDX,
});

// 3. 빌드 시 자동 검증
export default defineConfig({
  collections: [records, books, engineerings, projects],
  // 스키마 위반 시 빌드 실패
});
```


<strong>성과</strong>:

- 런타임 타입 에러 100% 제거
- 자동 완성 및 타입 추론 지원
- 빌드 시점에 오류 발견 (프로덕션 배포 전)

<strong>배운 점</strong>:

- <strong>스키마 우선 설계</strong>: 데이터 구조를 먼저 정의하고 코드 작성
- <strong>Zod의 강력함</strong>: 런타임 검증 + TypeScript 타입 생성
- <strong>개발자 경험</strong>: 타입 안전성이 생산성과 직결

### <strong>5. 대용량 빌드 최적화</strong>


<strong>도전 과제</strong>:

- 100+ MDX 파일 파싱: 3분+
- 메모리 사용량: 2GB+
- Vercel 빌드 타임아웃 위험

<strong>최적화 전략</strong>:


```plain text
// 1. 병렬 처리
export default defineConfig({
  parallel: true, // CPU 코어 수만큼 병렬 처리
  // 3분 → 1분 20초
});

// 2. 증분 빌드
export default defineConfig({
  incremental: true, // 변경된 파일만 재빌드
  // 1분 20초 → 45초 (수정 시)
});

// 3. Webpack 최적화
config.optimization = {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: { /* 벤더 분리 */ },
      mdx: { /* MDX 콘텐츠 분리 */ },
    },
  },
};
```


<strong>성과</strong>:

- 빌드 시간: 3분 → 45초 (75% 단축)
- 메모리 사용: 2GB → 1.2GB (40% 감소)
- Vercel 배포 시간: 4분 → 2분

<strong>배운 점</strong>:

- <strong>병렬 처리의 위력</strong>: CPU 바운드 작업은 멀티코어 활용 필수
- <strong>증분 빌드</strong>: 변경된 부분만 재빌드하여 개발 생산성 향상
- <strong>측정의 중요성</strong>: 최적화 전후 수치 비교로 효과 입증

### <strong>6. SEO 최적화와 크롤링 품질</strong>


<strong>도전 과제</strong>:

- 동적 렌더링으로 인한 SEO 품질 저하
- Google Search Console의 색인 오류
- Open Graph 메타데이터 불일치

<strong>해결 방안</strong>:


```plain text
// 1. 정적 메타데이터 생성
export async function generateMetadata({ params }): Promise<Metadata> {
  const post = allRecords.find(p => p.slug === params.slug);

  return {
    title: post.title,
    description: post.summary,
    openGraph: {
      title: post.title,
      description: post.summary,
      images: [post.pageCover],
      type: 'article',
      publishedTime: post.date.toISOString(),
      authors: [post.author],
    },
    // Twitter Card, JSON-LD 등
  };
}

// 2. Sitemap 자동 생성
export default function sitemap(): MetadataRoute.Sitemap {
  return allRecords.map(post => ({
    url: `https://example.com/records/${post.slug}`,
    lastModified: post.lastEditedDate,
    changeFrequency: 'weekly',
    priority: post.favorite ? 1.0 : 0.8,
  }));
}

// 3. Robots.txt
export default function robots(): MetadataRoute.Robots {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
      disallow: '/api/',
    },
    sitemap: 'https://example.com/sitemap.xml',
  };
}
```


<strong>성과</strong>:

- Google 색인: 50개 → 100+ 개 (100% 색인)
- Lighthouse SEO: 85 → 100
- Core Web Vitals: 모두 "Good" 등급

<strong>배운 점</strong>:

- <strong>정적 생성의 SEO 이점</strong>: 크롤러가 완전한 HTML을 받음
- <strong>메타데이터 일관성</strong>: Next.js Metadata API로 표준화
- <strong>Sitemap의 중요성</strong>: 검색 엔진의 색인 속도 향상

## <strong>👨‍💻 개인 기여 요약</strong> 


---


### <strong>엔드투엔드 오너십</strong>


| <strong>영역</strong>       | <strong>상세 내용</strong>                                    | <strong>성과</strong>                       |
| ------------ | -------------------------------------------- | ---------------------------- |
| <strong>기획 & 설계</strong>  | 요구사항 정의 → 기술 스택 선정 → 아키텍처 설계 → 마일스톤 수립       | 4개월 로드맵 수립 및 단계별 달성          |
| <strong>개발 & 구현</strong>  | 프론트엔드 100% 구현 (컴포넌트 80+, 페이지 20+, 유틸 50+)    | 15,000 LOC, TypeScript 87.3% |
| <strong>인프라 & 배포</strong> | Vercel 배포 설정, Redis 캐싱, Cloudinary CDN, 모니터링 | 자동 배포 파이프라인 구축               |
| <strong>품질 & 테스트</strong> | ESLint/Prettier 설정, 타입 안전성 확보, 성능 최적화        | Lighthouse 96점, 타입 에러 0건     |


## <strong>기술적 리더십</strong>


<strong>1. 아키텍처 의사결정</strong>

- react-notion-x 폐기 결정 주도
- 3번의 실패를 거쳐 최종 아키텍처 확정
- 정적 파이프라인 설계로 성능 60% 향상

<strong>2. 문제 해결 임팩트</strong>


| <strong>문제</strong>     | <strong>해결책</strong>                   | <strong>결과</strong>            |
| ---------- | ------------------------- | ----------------- |
| 하이드레이션 오류  | 정적 생성 전환                  | 오류 100% 제거        |
| Rate Limit | 빌드 시점 변환                  | 빌드 시간 85% 단축      |
| 이미지 만료     | Cloudinary + Redis        | 영구 보존 + 70% 크기 감소 |
| 타입 불일치     | Zod + Content Collections | 런타임 에러 100% 제거    |
| 느린 빌드      | 병렬/증분 빌드                  | 75% 시간 단축         |


<strong>3. 코드 품질 & 유지보수성</strong>


```plain text
품질 지표:
- TypeScript strict mode: 100% 준수
- ESLint 규칙: 120+ 규칙 적용
- 코드 리뷰: 자체 체크리스트로 품질 관리
- 문서화: README 1000+ 라인, 주석 상세

아키텍처 원칙:
- Atomic Design: 컴포넌트 재사용성 극대화
- 관심사 분리: UI/로직/데이터 계층 명확히 구분
- 타입 안전: Zod + TypeScript로 런타임 보장
- 성능 우선: 모든 결정은 성능 데이터 기반
```


## <strong>성장 & 학습</strong>


<strong>배운 기술</strong>

- <strong>Next.js 15 App Router</strong>: Server Component, Metadata API, ISR
- <strong>Content Collections</strong>: 타입 안전 콘텐츠 관리
- <strong>Fumadocs</strong>: 문서화 시스템 통합
- <strong>Cloudinary</strong>: 이미지 최적화 및 CDN
- <strong>Upstash Redis</strong>: 서버리스 캐싱
- <strong>Zod</strong>: 런타임 타입 검증

<strong>성장 스토리</strong>

1. <strong>실패 경험의 가치</strong>: react-notion-x → SSR/ISR → 하이브리드의 실패가 최종 아키텍처의 단순함을 이끌어냄
2. <strong>성능 최적화 역량</strong>: Lighthouse 60점 → 96점까지 체계적 개선
3. <strong>문제 해결 능력</strong>: 각 단계에서 만난 문제를 구조적으로 해결
4. <strong>아키텍처 사고</strong>: 단기 해결책보다 장기 유지보수를 고려한 설계

### <strong>비즈니스 임팩트</strong>


```plain text
정량적 성과:
- 초기 로딩 속도: 2.5s → 1.0s (60% 향상)
- 번들 크기: 2.3MB → 890KB (61% 감소)
- 빌드 시간: 3분 → 45초 (75% 단축)
- SEO 점수: 85 → 100 (Lighthouse)
- 색인 페이지: 50개 → 100+ 개

정성적 성과:
- 유지보수 비용 대폭 감소 (단일 렌더링 경로)
- 개발자 경험 향상 (타입 안전성, 자동 완성)
- 확장 가능한 아키텍처 (새 기능 추가 용이)
- 안정적 운영 (런타임 의존성 제거)
```


### <strong>차별화 포인트</strong>

1. <strong>단독 수행</strong>: 기획부터 배포까지 전 과정 100% 수행
2. <strong>실패 경험</strong>: 3번의 시도와 실패를 통한 최적 솔루션 도출
3. <strong>측정 기반</strong>: 모든 최적화에 Before/After 수치 제시
4. <strong>문서화</strong>: 기술 의사결정 과정까지 상세 기록
5. <strong>오픈소스</strong>: 전체 코드 공개로 투명성 확보

## <strong>🚀 개발 로드맵</strong>


---


### <strong>✅ 완료된 기능 (v1.0)</strong>

- [x] Notion → MDX 자동 변환 파이프라인
- [x] Cloudinary + Redis 이미지 최적화
- [x] Content Collections 타입 안전 시스템
- [x] 카테고리별 콘텐츠 관리 (4개 카테고리)
- [x] 커맨드 팔레트 & 검색 기능
- [x] MDX 커스텀 컴포넌트 시스템
- [x] 다크 모드 & 테마 시스템
- [x] SEO 최적화 (Sitemap, Robots, Metadata)
- [x] 반응형 디자인
- [x] Vercel 자동 배포

<strong>🚧 진행 중 (v1.1 - 2025 Q1)</strong>

- [x] <strong>성능 최적화</strong>
    - [x] Service Worker 도입
    - [ ] PWA 기능 추가
    - [x] Lighthouse 점수 98+ 달성
- [x] <strong>검색 고도화</strong>
    - [x] 전문 검색 (Full-text search)
    - [x] 검색 결과 하이라이팅
    - [x] 검색 기록 및 추천
- [x] <strong>콘텐츠 기능</strong>
    - [ ] RSS/Atom 피드
    - [x] 댓글 시스템 (Giscus)
    - [x] 목차 (Table of Contents) 자동 생성

### <strong>📅 계획 중 (v2.0 - 2025 Q4)</strong>

- [ ] <strong>다국어 지원 (i18n)</strong>
    - [ ] 한국어/영어 자동 경로 매핑
    - [ ] 콘텐츠 번역 시스템
- [ ] <strong>인터랙티브 기능</strong>
    - [x] 독자 통계 (조회수, 읽기 시간)
    - [x] 소셜 공유 기능

### <strong>🔮 미래 비전 (v3.0+)</strong>

- [ ] <strong>AI 기반 기능</strong>
    - [ ] 자동 태그 생성
    - [ ] 콘텐츠 추천 시스템
    - [ ] 요약 자동 생성
- [ ] <strong>협업 기능</strong>
    - [ ] 멀티 작성자 지원
- [ ] <strong>자동화</strong>
    - [ ] GitHub Actions CI/CD

## <strong>📊 프로젝트 통계</strong>


---


### <strong>코드베이스</strong>


```plain text
Languages:
  TypeScript:  87.3% (타입 안전 중심)
  TSX:         8.2%  (React 컴포넌트)
  JavaScript:  2.1%  (설정 파일)
  CSS:         1.8%  (스타일)
  Other:       0.6%

Lines of Code: ~15,000 LOC
Files:         250+ files
Components:    80+ React components
Pages:         20+ routes
Utilities:     50+ helper functions
```


### <strong>콘텐츠</strong>


```plain text
총 콘텐츠:      100+ posts
카테고리:       4개 (Engineering, Project, Book, Record)
서브타입:       15+ 세부 분류
태그:          50+ tags
이미지:        200+ optimized images (Cloudinary CDN)
평균 글자수:    2,000+ 자/포스트
```


### <strong>성능 지표</strong>


```plain text
Build Time:     45초 (100+ MDX 파일, 병렬 처리)
Deploy Time:    2분 (Vercel, 자동 배포)
Initial Load:   < 1초 (SSG + CDN)
Page Size:      180KB (gzipped, 번들 최적화)
TTFB:          < 200ms (Edge Network)
LCP:           1.2초 (Largest Contentful Paint)
FID:           12ms (First Input Delay)
CLS:           0.02 (Cumulative Layout Shift)
```


### <strong>의존성</strong>


```plain text
Total Packages:     135개
Production:         109개
Development:        26개
주요 라이브러리:
  - Next.js 15.4.1
  - React 19.1.0
  - TypeScript 5.6.3
  - Tailwind CSS 4.1.11
  - Content Collections 0.10.0
```


### <strong>마이그레이션 성과</strong>


| <strong>지표</strong>            | <strong>Before (react-notion-x)</strong> | <strong>After (MDX)</strong> | <strong>개선률</strong> |
| ----------------- | --------------------------- | --------------- | ------- |
| <strong>초기 로딩</strong>         | 2.5s                        | 1.0s            | ↓ 60%   |
| <strong>번들 크기</strong>         | 2.3MB                       | 890KB           | ↓ 61%   |
| <strong>빌드 시간</strong>         | 3분+                         | 45초             | ↓ 75%   |
| <strong>하이드레이션 오류</strong>     | 빈번                          | 0건              | ✅ 100%  |
| <strong>Lighthouse 점수</strong> | 60                          | 96              | ↑ 60%   |
| <strong>SEO 색인</strong>        | 50개                         | 100+ 개          | ↑ 100%  |


## <strong>🤝 기여 & 피드백</strong>


이 프로젝트는 개인 프로젝트이지만, 피드백과 제안은 언제나 환영합니다!


---


<strong>피드백 방법</strong>

- 📧 Email: [devseryun@gmail.com](mailto:devseryun@gmail.com)
- 💼 LinkedIn: [ryoonwithinwisdomlights](https://www.linkedin.com/in/ryoonwithinwisdomlights)
- 🐱 GitHub Issues: [이슈 생성](https://github.com/ryoonwithinwisdomlights/norkive/issues)

## <strong>🙏 감사의 말</strong>


---


이 프로젝트는 다음 오픈소스 프로젝트의 영향을 받았습니다:

- [Next.js](https://nextjs.org/) - React 프레임워크
- [Fumadocs](https://fumadocs.vercel.app/) - 문서화 시스템
- [Radix UI](https://www.radix-ui.com/) - Headless UI 컴포넌트
- [Tailwind CSS](https://tailwindcss.com/) - CSS 프레임워크
- [Vercel](https://vercel.com/) - 호스팅 플랫폼

## <strong>📄 라이선스</strong>


---


이 프로젝트는 [MIT License](https://github.com/ryoonwithinwisdomlights/MdxNorkive/blob/main/LICENSE)로 배포됩니다.


## <strong>👤 작성자</strong>


---


<strong>Ryoon with Wisdom Lights</strong>

> "기록을 엔지니어링하고, 지식을 아카이브합니다."
- 🌐 Website: [https://www.ryoonwithwisdomtrees.world/](https://www.ryoonwithwisdomtrees.world/)
- 📧 Email: [ryoon.with.wisdomtrees@gmail.com](mailto:ryoon.with.wisdomtrees@gmail.com)
- 🐱 GitHub: [@ryoonwithinwisdomlights](https://github.com/ryoonwithinwisdomlights)

---


<strong>⭐ 이 프로젝트가 도움이 되셨다면 Star를 눌러주세요!</strong>


Made with ❤️ by Ryoon with Wisdom Lights

