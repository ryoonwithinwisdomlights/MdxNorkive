---
title: '[TIL] Refactoring SearchInput.'
slug: engineerings-TIL-Refactoring-SearchInput
summary: ''
pageCover: >-
  https://images.unsplash.com/photo-1593062096033-9a26b09da705?ixlib=rb-4.0.3&q=85&fm=jpg&crop=entropy&cs=srgb
notionId: 2231eb5c0337804eadfce7368b604088
password: ''
type: ENGINEERINGS
sub_type: TIL
category: TIL
tags:
  - usememo
favorite: true
date: '2025-07-01'
last_edited_time: '2025-08-09T14:49:00.000Z'
lastEditedDate: 2025-08-09T14:49:00.000Z
draft: false
description: ''
icon: ''
full: false
lastModified: '2025-08-09'
readingTime: 17
wordCount: 3255
status: published
author: ryoonwithinwisdomlights
version: 1.0.0
---

## <strong>✅ 전체 코드 개념 잡기</strong>


![스크린샷_2025-07-11_오후_2.12.58.png](https://res.cloudinary.com/dyrdul1dd/image/upload/v1754751395/norkive-notion-images/1754751393129-E1_84_89_E1_85_B3_E1_84_8F_E1_85_B3_E1_84_85_E1_85_B5_E1_86_AB_E1_84_89_E1_85_A3_E1_86_BA_2025-07-11_E1_84_8B_E1_85_A9_E1_84_92_E1_85_AE_2.12.58.png)


### <strong>1.</strong>


### <strong>Fuse.js</strong>

- <strong>뭐야?</strong>

    자바스크립트용 <strong>빠른 클라이언트 사이드 검색 라이브러리</strong>.


    검색어가 “부정확하게” 일치해도 유사도를 기반으로 결과를 찾아줘. (부분 검색, 오타 관용적)

- <strong>여기서 쓰는 이유?</strong>

    백엔드 API 없이 그냥 <strong>더미 배열</strong>에서 실시간 검색 테스트하려고.

- <strong>사용 방법:</strong>

```typescript
const fuse = new Fuse(대상데이터, 옵션);
fuse.search(검색어); // 결과 배열 반환
```


### <strong>2.</strong>


### <strong>lodash.debounce</strong>

- <strong>뭐야?</strong>

    사용자가 입력할 때마다 <strong>계속 검색 호출 안 되게 딜레이 걸어주는 함수</strong>.

- <strong>여기서 쓰는 이유?</strong>

    한 글자 입력할 때마다 실시간 검색하면 너무 많은 연산 낭비 → <strong>0.3초 입력 멈추면 그때 검색</strong>

- <strong>사용 방법:</strong>

    ```typescript
    const debouncedFn = debounce((text) => { ...검색로직... }, 300);
    ```


### <strong>3.</strong>


### <strong>useMemo</strong>

- <strong>뭐야?</strong>

    React에서 특정 값이나 객체를 <strong>메모이제이션(캐시)</strong> 해서,


    <strong>렌더링마다 새로 생성되는 걸 방지</strong>하는 훅.

- <strong>여기서 왜 씀?</strong>

    Fuse 인스턴스를 매번 새로 만들지 않기 위해.

- <strong>사용 예시:</strong>

    ```typescript
    const fuse = useMemo(() => new Fuse(데이터), []);
    ```



 <strong>전체 동작 흐름</strong>



```plain text
[1] 사용자가 input에 타이핑 → setQuery 변경됨
↓
[2] query 상태 변경 → useEffect 실행됨
↓
[3] useEffect 안에서 debounce된 handleSearch 실행됨 (300ms 딜레이)
↓
[4] handleSearch 내부:
- query 길이 체크
- fuse.search() 실행 → 결과 배열 만들기
- setResults로 검색결과 상태 업데이트
↓
[5] 결과 표시 영역에서:
- 로딩중일 때 Skeleton
- 검색결과 있을 때 리스트로 출력
- 없으면 "No results found"
```



<strong>✅ 주요 State 설명</strong>



| <strong>tate</strong> | <strong>역할</strong>            |
| -------- | ----------------- |
| query    | 현재 input 값        |
| results  | 검색 결과 배열          |
| loading  | Skeleton 출력 여부 제어 |



<strong>✅ 주요 Hook/로직 정리</strong>



| <strong>항목</strong>        | <strong>설명</strong>                        |
| ------------- | ----------------------------- |
| useState      | query, results, loading 상태 관리 |
| useEffect     | query가 바뀔 때마다 debounce로 검색 실행 |
| useMemo       | fuse 인스턴스 재생성 방지              |
| debounce      | 검색 호출 최적화                     |
| fuse.search() | 입력어 기반 검색                     |



<strong>✅ 확장 작업 시 적용 포인트</strong>



| <strong>기능</strong>             | <strong>적용 위치</strong>                                        |
| ------------------ | ------------------------------------------------ |
| <strong>Algolia 연동</strong>     | → handleSearch 내부 fuse.search 대신 <strong>axios fetch</strong> |
| <strong>Next.js &lt;Link&gt;</strong> | → 리스트 출력 부분 &lt;a href&gt; 대신 &lt;Link href&gt;              |
| <strong>서버 API</strong>         | → handleSearch 내부를 <strong>API 호출 비동기 함수</strong>로 변경         |
| <strong>Skeleton 커스텀</strong>   | → loading 상태일 때 보여주는 div 영역만 수정                  |


## <strong>✅ 요약:</strong>


지금 코드는 👉


<strong>[로컬 배열 + Fuse 검색 + debounce 최적화 + 다크모드 + Skeleton]</strong>


이 조합으로 구성된 <strong>Next.js 클라이언트 컴포넌트형 검색 Input UI</strong>

