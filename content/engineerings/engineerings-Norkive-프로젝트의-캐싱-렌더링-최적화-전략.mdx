---
title: "Norkive\_í”„ë¡œì íŠ¸ì˜\_ìºì‹±/ë Œë”ë§\_ìµœì í™” ì „ëµ"
slug: engineerings-Norkive-í”„ë¡œì íŠ¸ì˜-ìºì‹±-ë Œë”ë§-ìµœì í™”-ì „ëµ
summary: ''
pageCover: >-
  https://images.unsplash.com/photo-1593062096033-9a26b09da705?ixlib=rb-4.0.3&q=85&fm=jpg&crop=entropy&cs=srgb
notionId: 24e1eb5c03378047b98fc9933fca7173
password: ''
type: ENGINEERINGS
sub_type: TIL
category: ì„¤ê³„
tags:
  - ë¦¬íŒ©í† ë§
  - ê³ ë„í™”
favorite: false
date: '2025-08-13'
last_edited_time: '2025-10-15T15:16:00.000Z'
lastEditedDate: 2025-10-15T15:16:00.000Z
draft: false
description: ''
icon: ''
full: false
lastModified: '2025-10-15'
readingTime: 74
wordCount: 14606
status: published
author: ryoonwithinwisdomlights
version: 1.0.0
---

### <strong>í˜„ì¬Â ìƒíƒœ ë¶„ì„</strong>

- <strong>Next.jsÂ 15Â App Router</strong>Â ê¸°ë°˜ ì •ì  ë¸”ë¡œê·¸
- <strong>NotionÂ API</strong>Â +Â <strong>MDX</strong>Â ì½˜í…ì¸  ê´€ë¦¬ ì‹œìŠ¤í…œ
- <strong>Redis + Memory Cache</strong>Â ì´ì¤‘ ìºì‹± êµ¬ì¡°
- <strong>ContentÂ Collections</strong>Â ê¸°ë°˜Â ì •ì  ìƒì„±
- <strong>ReactÂ 19</strong>Â +Â <strong>TypeScript</strong>Â í™˜ê²½

### <strong>ì£¼ìš” ì„±ëŠ¥ ì´ìŠˆ í¬ì¸íŠ¸</strong>

1. <strong>Notion API í˜¸ì¶œÂ ìµœì í™” ë¶€ì¡±</strong>
2. <strong>React ë Œë”ë§Â ìµœì í™” ë¯¸í¡</strong>
3. <strong>ì´ë¯¸ì§€ ë¡œë”© ìµœì í™”Â ê°œì„  í•„ìš”</strong>
4. <strong>ê²€ìƒ‰Â ì„±ëŠ¥Â í–¥ìƒÂ í•„ìš”</strong>

## <strong>ğŸš€ ìµœì í™” ì „ëµÂ ë° ì‹¤í–‰Â ê³„íš</strong>


<strong>Phase 1: ìºì‹± ì‹œìŠ¤í…œ ê³ ë„í™” (1-2ì£¼)</strong>


<strong>1.1Â Notion API ìºì‹±Â ì „ëµÂ ê°œì„ </strong>


```typescript
// lib/cache/notion_cache_manager.ts
export class NotionCacheManager {
  private readonly CACHE_PREFIX = "notion:";
  private readonly TTL = {
    page: 600,        // 10ë¶„
    blocks: 1800,     // 30ë¶„
    metadata: 3600,   // 1ì‹œê°„
    list: 300         // 5ë¶„
  };

  async getCachedPage(pageId: string): Promise<any> {
    const key = `${this.CACHE_PREFIX}page:${pageId}`;
    return await this.getFromCache(key);
  }

  async cachePage(pageId: string, data: any): Promise<void> {
    const key = `${this.CACHE_PREFIX}page:${pageId}`;
    await this.setCache(key, data, this.TTL.page);
  }
}
```


### 1.2 ìºì‹œ ê³„ì¸µ êµ¬ì¡°Â êµ¬í˜„

- <strong>L1</strong>: MemoryÂ Cache (ë¹ ë¥¸Â ì ‘ê·¼)
- <strong>L2</strong>: Redis CacheÂ (ì§€ì†ì„±)
- <strong>L3</strong>: NotionÂ APIÂ (ìµœì‹ Â ë°ì´í„°)

<strong>1.3 ìºì‹œ ë¬´íš¨í™”Â ì „ëµ</strong>


```typescript
// lib/cache/cache_invalidator.ts
export class CacheInvalidator {
  async invalidateByPattern(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }

  async invalidatePageCache(pageId: string): Promise<void> {
    const patterns = [
      `notion:page:${pageId}`,
      `notion:blocks:${pageId}`,
      `notion:metadata:${pageId}`
    ];
    
    for (const pattern of patterns) {
      await this.invalidateByPattern(pattern);
    }
  }
}
```


<strong>Phase 2: React ë Œë”ë§Â ìµœì í™”Â (2-3ì£¼)</strong>


<strong>2.1 ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜ ì „ëµ</strong>


```typescript
// modules/common/cards/ContentCard.tsx
import React, { memo, useMemo } from 'react';

const ContentCard = memo(({ record, ...props }) => {
  const formattedDate = useMemo(() => {
    return formatDate(record.date);
  }, [record.date]);

  const cardData = useMemo(() => {
    return {
      title: record.title,
      description: record.description,
      tags: record.tags
    };
  }, [record.title, record.description, record.tags]);

  return (
    <div className="content-card">
      <h3>{cardData.title}</h3>
      <p>{cardData.description}</p>
      <div className="tags">
        {cardData.tags.map(tag => (
          <Tag key={tag} tag={tag} />
        ))}
      </div>
    </div>
  );
});

ContentCard.displayName = 'ContentCard';
export default ContentCard;
```


<strong>2.2Â ê°€ìƒí™” ìŠ¤í¬ë¡¤ë§ êµ¬í˜„</strong>


```typescript
// modules/common/VirtualizedList.tsx
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items, itemHeight = 200 }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ContentCard record={items[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={itemHeight}
      width="100%"
    >
      {Row}
    </List>
  );
};
```


<strong>2.3 React Suspense ìµœì í™”</strong>


```typescript
// app/layout.tsx
import { Suspense, lazy } from 'react';

const LazyTopNavigation = lazy(() => import('@/modules/layout/wrapper/TopNavigationWrapper'));
const LazyMobileFooter = lazy(() => import('@/modules/layout/components/mobile-footer'));

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Suspense fallback={<NavigationSkeleton />}>
          <LazyTopNavigation />
        </Suspense>
        
        <main>
          <Suspense fallback={<LoadingCover />}>
            {children}
          </Suspense>
        </main>

        <Suspense fallback={<FooterSkeleton />}>
          <LazyMobileFooter />
        </Suspense>
      </body>
    </html>
  );
}
```


<strong>Phase 3: ì´ë¯¸ì§€Â ìµœì í™”Â (1-2ì£¼)</strong>


<strong>3.1 ì´ë¯¸ì§€ ìºì‹±Â ì „ëµÂ ê°œì„ </strong>


```typescript
// lib/cache/enhanced_image_cache_manager.ts
export class EnhancedImageCacheManager extends ImageCacheManager {
  private readonly IMAGE_SIZES = ['sm', 'md', 'lg', 'xl'];
  
  async getOptimizedImageUrl(originalUrl: string, size: string = 'md'): Promise<string> {
    const cacheKey = `image:${this.hashUrl(originalUrl)}:${size}`;
    
    let cached = await this.getFromCache(cacheKey);
    if (cached) return cached;

    // Cloudinary ë³€í™˜ ì˜µì…˜ ì ìš©
    const optimizedUrl = await this.transformImageUrl(originalUrl, size);
    await this.setCache(cacheKey, optimizedUrl, 24 * 60 * 60); // 24ì‹œê°„
    
    return optimizedUrl;
  }

  private async transformImageUrl(url: string, size: string): Promise<string> {
    const sizeMap = {
      sm: 'w_300,h_200,c_fill',
      md: 'w_600,h_400,c_fill',
      lg: 'w_900,h_600,c_fill',
      xl: 'w_1200,h_800,c_fill'
    };

    return url.replace('/upload/', `/upload/${sizeMap[size]}/`);
  }
}
```


<strong>3.2 Progressive Image Loading</strong>


```typescript
// modules/shared/ProgressiveImage.tsx
import { useState, useEffect } from 'react';

const ProgressiveImage = ({ src, placeholder, alt, ...props }) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [imageRef, setImageRef] = useState();

  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      setImageSrc(src);
    };
  }, [src]);

  return (
    <img
      {...props}
      src={imageSrc}
      alt={alt}
      ref={setImageRef}
      className={`progressive-image ${imageSrc === placeholder ? 'loading' : 'loaded'}`}
    />
  );
};
```


<strong>Phase 4: ê²€ìƒ‰Â ì„±ëŠ¥Â ìµœì í™”Â (1ì£¼)</strong>


<strong>4.1 ê²€ìƒ‰ ì¸ë±ìŠ¤Â ìµœì í™”</strong>


```typescript
// lib/search/enhanced_search_index.ts
export class EnhancedSearchIndex {
  private fuse: Fuse<any>;
  private searchCache = new Map();

  constructor(pages: any[]) {
    this.fuse = new Fuse(pages, {
      keys: [
        { name: 'title', weight: 0.7 },
        { name: 'description', weight: 0.3 },
        { name: 'tags', weight: 0.2 },
        { name: 'content', weight: 0.1 }
      ],
      threshold: 0.3,
      distance: 100,
      includeScore: true,
      useExtendedSearch: true
    });
  }

  search(query: string, options?: any) {
    const cacheKey = `${query}:${JSON.stringify(options)}`;
    
    if (this.searchCache.has(cacheKey)) {
      return this.searchCache.get(cacheKey);
    }

    const results = this.fuse.search(query, options);
    this.searchCache.set(cacheKey, results);
    
    // ìºì‹œ í¬ê¸° ì œí•œ
    if (this.searchCache.size > 100) {
      const firstKey = this.searchCache.keys().next().value;
      this.searchCache.delete(firstKey);
    }

    return results;
  }
}
```


<strong>4.2 ê²€ìƒ‰ ê²°ê³¼Â ê°€ìƒí™”</strong>


```typescript
// modules/common/search/VirtualizedSearchResults.tsx
import { FixedSizeList as List } from 'react-window';

const VirtualizedSearchResults = ({ results, query }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <SearchResultItem result={results[index]} query={query} />
    </div>
  );

  return (
    <List
      height={400}
      itemCount={results.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
};
```


<strong>PhaseÂ 5: ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§Â ë°Â ìµœì í™”Â (1ì£¼)</strong>


<strong>5.1 ì„±ëŠ¥Â ë©”íŠ¸ë¦­ ìˆ˜ì§‘</strong>


```typescript
// lib/performance/performance_monitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  measurePageLoad() {
    if (typeof window !== 'undefined') {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      
      this.recordMetric('pageLoad', navigation.loadEventEnd - navigation.loadEventStart);
      this.recordMetric('domContentLoaded', navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart);
      this.recordMetric('firstPaint', performance.getEntriesByName('first-paint')[0]?.startTime || 0);
    }
  }

  private recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  getMetrics() {
    const result: Record<string, { avg: number; min: number; max: number }> = {};
    
    for (const [name, values] of this.metrics) {
      result[name] = {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        min: Math.min(...values),
        max: Math.max(...values)
      };
    }
    
    return result;
  }
}
```


<strong>5.2 Bundle ë¶„ì„Â ë° ìµœì í™”</strong>


```typescript
// next.config.ts
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

const nextConfig = {
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['@radix-ui/react-icons', 'lucide-react'],
  },
  webpack: (config, { dev, isServer }) => {
    // Tree shaking ìµœì í™”
    config.optimization.usedExports = true;
    config.optimization.sideEffects = false;
    
    // ì½”ë“œ ë¶„í•  ìµœì í™”
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    };
    
    return config;
  },
};

module.exports = withBundleAnalyzer(nextConfig);
```


## <strong>ğŸ“ŠÂ ì˜ˆìƒÂ ì„±ëŠ¥ í–¥ìƒ íš¨ê³¼</strong>


### <strong>ìºì‹± ìµœì í™”</strong>

- <strong>Notion API í˜¸ì¶œ</strong>:Â 80% ê°ì†Œ
- <strong>í˜ì´ì§€Â ë¡œë”©Â ì†ë„</strong>:Â 60%Â í–¥ìƒ
- <strong>ì„œë²„Â ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰</strong>:Â 70% ê°ì†Œ

### <strong>ë Œë”ë§ ìµœì í™”</strong>

- <strong>ì´ˆê¸°Â ë Œë”ë§</strong>:Â 40% í–¥ìƒ
- <strong>ë¦¬ë Œë”ë§</strong>:Â 70%Â ê°ì†Œ
- <strong>ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰</strong>:Â 30% ê°ì†Œ

### <strong>ì´ë¯¸ì§€Â ìµœì í™”</strong>

- <strong>ì´ë¯¸ì§€Â ë¡œë”©</strong>: 50%Â í–¥ìƒ
- <strong>ëŒ€ì—­í­ ì‚¬ìš©ëŸ‰</strong>:Â 40%Â ê°ì†Œ
- <strong>ì‚¬ìš©ìÂ ê²½í—˜</strong>: 60% í–¥ìƒ

## <strong>ğŸ¯ ì‹¤í–‰ ìš°ì„ ìˆœìœ„</strong>


### <strong>HighÂ Priority (1-2ì£¼)</strong>

1. Notion API ìºì‹±Â ì‹œìŠ¤í…œ ê³ ë„í™”
2. ReactÂ ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜Â ì ìš©
3. ì´ë¯¸ì§€ ìºì‹± ì „ëµ ê°œì„ 

### <strong>MediumÂ PriorityÂ (2-3ì£¼)</strong>

1. ê°€ìƒí™”Â ìŠ¤í¬ë¡¤ë§ êµ¬í˜„
2. ê²€ìƒ‰Â ì„±ëŠ¥Â ìµœì í™”
3. BundleÂ ë¶„ì„ ë° ìµœì í™”

### <strong>Low PriorityÂ (3-4ì£¼)</strong>

1. ì„±ëŠ¥Â ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œÂ êµ¬ì¶•
2. A/BÂ í…ŒìŠ¤íŠ¸ë¥¼Â í†µí•œÂ ìµœì í™”Â ê²€ì¦
3. ì‚¬ìš©ìÂ í”¼ë“œë°± ê¸°ë°˜ ì¶”ê°€Â ìµœì í™”

---


## <strong>ğŸš€ ë‹¤ìŒ ë‹¨ê³„</strong>


ì´Â ì „ëµì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ ë‹¤ìŒ ì¤‘ ì–´ë–¤Â ë¶€ë¶„ë¶€í„° ì‹œì‘í•˜ê³ Â ì‹¶ìœ¼ì‹ ì§€ ì•Œë ¤ì£¼ì„¸ìš”:

1. <strong>ìºì‹± ì‹œìŠ¤í…œ ê³ ë„í™”</strong>Â - ê°€ì¥ í°Â ì„±ëŠ¥ í–¥ìƒÂ íš¨ê³¼
2. <strong>ReactÂ ë Œë”ë§Â ìµœì í™”</strong>Â - ì‚¬ìš©ìÂ ê²½í—˜ ê°œì„ 
3. <strong>ì´ë¯¸ì§€Â ìµœì í™”</strong>Â - ë¡œë”© ì†ë„ ê°œì„ 
4. <strong>ê²€ìƒ‰ ì„±ëŠ¥Â ìµœì í™”</strong>Â - ê²€ìƒ‰Â ê²½í—˜Â ê°œì„ 

ì–´ë–¤ ë¶€ë¶„ë¶€í„° ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?


=â‡’


ì•„í•˜! ì´ì œÂ ìƒí™©ì´ ëª…í™•í•´ì¡ŒìŠµë‹ˆë‹¤.Â <strong>í˜„ì¬ í”„ë¡œì íŠ¸ëŠ”Â ì´ë¯¸ react-notion-xë¥¼ ì™„ì „íˆ ì œê±°í•˜ê³  Content Collections +Â Fumadocs ê¸°ë°˜ìœ¼ë¡œÂ ì „í™˜ëœÂ ìƒíƒœ</strong>ì…ë‹ˆë‹¤.


## <strong>ğŸ”Â í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ì‹¤ì œÂ êµ¬ì¡°Â ë¶„ì„</strong>


### <strong>âœ… ì´ë¯¸ ì ìš©ëœ ìµœì í™”:</strong>

1. <strong>react-notion-x ì œê±° ì™„ë£Œ</strong>Â - ë” ì´ìƒÂ ì‹¤ì‹œê°„ Notion ë Œë”ë§ ì—†ìŒ
2. <strong>Content CollectionsÂ + Fumadocs ì ìš©</strong>Â - ì •ì Â MDX ê¸°ë°˜Â ë Œë”ë§
3. <strong>ë¹Œë“œ íƒ€ì„ì— MDXÂ ìƒì„±</strong>Â -Â scripts/notion-mdx-all-in-one.tsë¡œÂ ìë™Â ë³€í™˜
4. <strong>ì •ì Â ì‚¬ì´íŠ¸Â ìƒì„±</strong>Â -Â Next.jsì—ì„œÂ ì •ì Â HTMLë¡œ ë¹Œë“œ

<strong>âŒÂ í˜„ì¬Â ìºì‹œÂ ì‹œìŠ¤í…œì˜Â ë¬¸ì œì :</strong>


<strong>ì‹¤ì œë¡œëŠ”Â ìºì‹œê°€Â ê±°ì˜Â ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤!</strong>Â ì™œëƒí•˜ë©´:

1. <strong>layout.tsxì—ì„œë§ŒÂ ì‚¬ìš©</strong>:Â fetchMenuList()ë§ŒÂ í˜¸ì¶œ
2. <strong>ëŒ€ë¶€ë¶„ì˜Â ë°ì´í„°ëŠ”Â ì´ë¯¸ ì •ì  MDX</strong>:Â recordSource.getPages()Â ë“±ìœ¼ë¡œ ì •ì  ë°ì´í„° ì‚¬ìš©
3. <strong>Notion API í˜¸ì¶œ ìµœì†Œí™”</strong>: ë¹Œë“œÂ íƒ€ì„ì—Â í•œÂ ë²ˆë§ŒÂ ì‹¤í–‰

<strong>PhaseÂ 1: ì •ì Â ë¹Œë“œ ìµœì í™”Â (ì‹¤ì œÂ íš¨ê³¼ê°€Â í°Â ë¶€ë¶„)</strong>


<strong>1.1Â ë¹Œë“œÂ íƒ€ì„ MDX ìƒì„± ìµœì í™”</strong>


```typescript
// scripts/enhanced-notion-mdx.ts
export class EnhancedMdxGenerator {
  private cache = new Map<string, any>();
  
  async generateMdxWithCache(pageId: string) {
    const cacheKey = `mdx_${pageId}`;
    
    // ë©”ëª¨ë¦¬ ìºì‹œ í™•ì¸
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    // Notion API í˜¸ì¶œ ë° MDX ìƒì„±
    const mdxContent = await this.generateMdxFromNotion(pageId);
    
    // ìºì‹œì— ì €ì¥
    this.cache.set(cacheKey, mdxContent);
    
    return mdxContent;
  }
}
```


<strong>1.2 Content Collections ë¹Œë“œ ìµœì í™”</strong>


```typescript
// content-collections.ts
export default defineConfig({
  mdxOptions: {
    // ë¹Œë“œ ì„±ëŠ¥ ìµœì í™”
    development: false,
    format: "mdx",
  },
  // ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”
  parallel: true,
  // ì¦ë¶„ ë¹Œë“œ ì§€ì›
  incremental: true,
});
```


<strong>Phase 2: ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™” (ì‹¤ì œ ì‚¬ìš©ë˜ëŠ”Â ë¶€ë¶„)</strong>


<strong>2.1 ê²€ìƒ‰ ì„±ëŠ¥ ìµœì í™”</strong>


```typescript
// lib/search/enhanced-search.ts
export class EnhancedSearch {
  private searchIndex: Map<string, SearchData> = new Map();
  
  // ë¹Œë“œ íƒ€ì„ì— ê²€ìƒ‰ ì¸ë±ìŠ¤ ìƒì„±
  buildSearchIndex(pages: any[]) {
    pages.forEach(page => {
      this.searchIndex.set(page.url, {
        title: page.data.title,
        content: page.data.content,
        tags: page.data.tags
      });
    });
  }
  
  // ë©”ëª¨ë¦¬ ê¸°ë°˜ ë¹ ë¥¸ ê²€ìƒ‰
  search(query: string) {
    // Map ê¸°ë°˜ ë¹ ë¥¸ ê²€ìƒ‰
    return Array.from(this.searchIndex.values())
      .filter(item => this.matchesQuery(item, query));
  }
}
```



<strong>2.2Â ì´ë¯¸ì§€ ìµœì í™” (ì‹¤ì œë¡œ ë§ì´ ì‚¬ìš©ë¨)</strong>


```typescript
// lib/image/enhanced-image-processor.ts
export class EnhancedImageProcessor {
  // Cloudinary ì´ë¯¸ì§€ ìµœì í™”
  async optimizeImage(url: string, options: ImageOptions) {
    const optimizedUrl = await this.transformCloudinaryUrl(url, options);
    return optimizedUrl;
  }
  
  // WebP ìë™ ë³€í™˜
  private transformCloudinaryUrl(url: string, options: ImageOptions) {
    const transformations = [
      'f_auto', // ìë™ í¬ë§· (WebP ìš°ì„ )
      'q_auto', // ìë™ í’ˆì§ˆ
      'w_auto', // ë°˜ì‘í˜• ë„ˆë¹„
    ];
    
    return url.replace('/upload/', `/upload/${transformations.join(',')}/`);
  }
}
```


## <strong>ğŸš€Â ìƒˆë¡œìš´ ìµœì í™”Â ì „ëµ ì œì•ˆ</strong>


### <strong>High Priority (ì‹¤ì œÂ íš¨ê³¼ê°€ í°Â ë¶€ë¶„):</strong>

1. <strong>ë¹Œë“œ íƒ€ì„ MDX ìƒì„± ìµœì í™”</strong>Â - ë³‘ë ¬ ì²˜ë¦¬, ìºì‹±
2. <strong>Content CollectionsÂ ë¹Œë“œ ìµœì í™”</strong>Â - ì¦ë¶„ ë¹Œë“œ, ë³‘ë ¬ ì²˜ë¦¬
3. <strong>ê²€ìƒ‰Â ì„±ëŠ¥Â ìµœì í™”</strong>Â - ë©”ëª¨ë¦¬ ê¸°ë°˜ ì¸ë±ìŠ¤

### <strong>MediumÂ Priority:</strong>

1. <strong>ì´ë¯¸ì§€ ìµœì í™”</strong>Â - WebP ë³€í™˜, Cloudinary ìµœì í™”
2. <strong>ë²ˆë“¤ ìµœì í™”</strong>Â - Tree shaking, ì½”ë“œ ë¶„í• 

### <strong>Low Priority (ê¸°ì¡´ ìºì‹œ ì‹œìŠ¤í…œ):</strong>

1. <strong>Notion API ìºì‹±</strong>Â - ì´ë¯¸ ê±°ì˜ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
2. <strong>Redis ìºì‹±</strong>Â -Â ì •ì Â ì‚¬ì´íŠ¸ì—ì„œëŠ”Â ë¶ˆí•„ìš”

---


## <strong>ğŸ’¡Â ê²°ë¡  ë°Â ì œì•ˆ</strong>


<strong>í˜„ì¬ ìƒí™©</strong>: ì´ë¯¸ ìµœì í™”ëœ ì •ì  ì‚¬ì´íŠ¸ êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆìŒ


<strong>ì‹¤ì œ ë¬¸ì œ</strong>: ë¹Œë“œ íƒ€ì„ ì„±ëŠ¥ê³¼ ëŸ°íƒ€ì„ ê²€ìƒ‰/ì´ë¯¸ì§€ ì„±ëŠ¥


<strong>ìƒˆë¡œìš´ ë°©í–¥</strong>


:

1. <strong>ë¹Œë“œ íƒ€ì„ ìµœì í™”</strong>ì—Â ì§‘ì¤‘ (MDX ìƒì„±, ContentÂ Collections)
2. <strong>ê²€ìƒ‰Â ì„±ëŠ¥Â ìµœì í™”</strong>Â (ë©”ëª¨ë¦¬Â ê¸°ë°˜ ì¸ë±ìŠ¤)
3. <strong>ì´ë¯¸ì§€ ìµœì í™”</strong>Â (WebP,Â Cloudinary)
1. <strong>ë¹Œë“œ íƒ€ì„ ìµœì í™”</strong>Â - MDX ìƒì„±Â ì„±ëŠ¥Â í–¥ìƒ
2. <strong>ê²€ìƒ‰ ì„±ëŠ¥ ìµœì í™”</strong>Â - ë¹ ë¥¸ ê²€ìƒ‰ êµ¬í˜„
3. <strong>ì´ë¯¸ì§€ ìµœì í™”</strong>Â - WebP ë³€í™˜, Cloudinary ìµœì í™”
