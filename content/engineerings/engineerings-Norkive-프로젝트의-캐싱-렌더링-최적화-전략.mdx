---
title: "Norkive\_프로젝트의\_캐싱/렌더링\_최적화 전략"
slug: engineerings-Norkive-프로젝트의-캐싱-렌더링-최적화-전략
summary: ''
pageCover: >-
  https://images.unsplash.com/photo-1593062096033-9a26b09da705?ixlib=rb-4.0.3&q=85&fm=jpg&crop=entropy&cs=srgb
notionId: 24e1eb5c03378047b98fc9933fca7173
password: ''
type: ENGINEERINGS
sub_type: TIL
category: 설계
tags:
  - 리팩토링
  - 고도화
favorite: false
date: '2025-08-13'
last_edited_time: '2025-10-15T15:16:00.000Z'
lastEditedDate: 2025-10-15T15:16:00.000Z
draft: false
description: ''
icon: ''
full: false
lastModified: '2025-10-15'
readingTime: 74
wordCount: 14606
status: published
author: ryoonwithinwisdomlights
version: 1.0.0
---

### <strong>현재 상태 분석</strong>

- <strong>Next.js 15 App Router</strong> 기반 정적 블로그
- <strong>Notion API</strong> + <strong>MDX</strong> 콘텐츠 관리 시스템
- <strong>Redis + Memory Cache</strong> 이중 캐싱 구조
- <strong>Content Collections</strong> 기반 정적 생성
- <strong>React 19</strong> + <strong>TypeScript</strong> 환경

### <strong>주요 성능 이슈 포인트</strong>

1. <strong>Notion API 호출 최적화 부족</strong>
2. <strong>React 렌더링 최적화 미흡</strong>
3. <strong>이미지 로딩 최적화 개선 필요</strong>
4. <strong>검색 성능 향상 필요</strong>

## <strong>🚀 최적화 전략 및 실행 계획</strong>


<strong>Phase 1: 캐싱 시스템 고도화 (1-2주)</strong>


<strong>1.1 Notion API 캐싱 전략 개선</strong>


```typescript
// lib/cache/notion_cache_manager.ts
export class NotionCacheManager {
  private readonly CACHE_PREFIX = "notion:";
  private readonly TTL = {
    page: 600,        // 10분
    blocks: 1800,     // 30분
    metadata: 3600,   // 1시간
    list: 300         // 5분
  };

  async getCachedPage(pageId: string): Promise<any> {
    const key = `${this.CACHE_PREFIX}page:${pageId}`;
    return await this.getFromCache(key);
  }

  async cachePage(pageId: string, data: any): Promise<void> {
    const key = `${this.CACHE_PREFIX}page:${pageId}`;
    await this.setCache(key, data, this.TTL.page);
  }
}
```


### 1.2 캐시 계층 구조 구현

- <strong>L1</strong>: Memory Cache (빠른 접근)
- <strong>L2</strong>: Redis Cache (지속성)
- <strong>L3</strong>: Notion API (최신 데이터)

<strong>1.3 캐시 무효화 전략</strong>


```typescript
// lib/cache/cache_invalidator.ts
export class CacheInvalidator {
  async invalidateByPattern(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }

  async invalidatePageCache(pageId: string): Promise<void> {
    const patterns = [
      `notion:page:${pageId}`,
      `notion:blocks:${pageId}`,
      `notion:metadata:${pageId}`
    ];
    
    for (const pattern of patterns) {
      await this.invalidateByPattern(pattern);
    }
  }
}
```


<strong>Phase 2: React 렌더링 최적화 (2-3주)</strong>


<strong>2.1 컴포넌트 메모이제이션 전략</strong>


```typescript
// modules/common/cards/ContentCard.tsx
import React, { memo, useMemo } from 'react';

const ContentCard = memo(({ record, ...props }) => {
  const formattedDate = useMemo(() => {
    return formatDate(record.date);
  }, [record.date]);

  const cardData = useMemo(() => {
    return {
      title: record.title,
      description: record.description,
      tags: record.tags
    };
  }, [record.title, record.description, record.tags]);

  return (
    <div className="content-card">
      <h3>{cardData.title}</h3>
      <p>{cardData.description}</p>
      <div className="tags">
        {cardData.tags.map(tag => (
          <Tag key={tag} tag={tag} />
        ))}
      </div>
    </div>
  );
});

ContentCard.displayName = 'ContentCard';
export default ContentCard;
```


<strong>2.2 가상화 스크롤링 구현</strong>


```typescript
// modules/common/VirtualizedList.tsx
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items, itemHeight = 200 }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ContentCard record={items[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={itemHeight}
      width="100%"
    >
      {Row}
    </List>
  );
};
```


<strong>2.3 React Suspense 최적화</strong>


```typescript
// app/layout.tsx
import { Suspense, lazy } from 'react';

const LazyTopNavigation = lazy(() => import('@/modules/layout/wrapper/TopNavigationWrapper'));
const LazyMobileFooter = lazy(() => import('@/modules/layout/components/mobile-footer'));

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Suspense fallback={<NavigationSkeleton />}>
          <LazyTopNavigation />
        </Suspense>
        
        <main>
          <Suspense fallback={<LoadingCover />}>
            {children}
          </Suspense>
        </main>

        <Suspense fallback={<FooterSkeleton />}>
          <LazyMobileFooter />
        </Suspense>
      </body>
    </html>
  );
}
```


<strong>Phase 3: 이미지 최적화 (1-2주)</strong>


<strong>3.1 이미지 캐싱 전략 개선</strong>


```typescript
// lib/cache/enhanced_image_cache_manager.ts
export class EnhancedImageCacheManager extends ImageCacheManager {
  private readonly IMAGE_SIZES = ['sm', 'md', 'lg', 'xl'];
  
  async getOptimizedImageUrl(originalUrl: string, size: string = 'md'): Promise<string> {
    const cacheKey = `image:${this.hashUrl(originalUrl)}:${size}`;
    
    let cached = await this.getFromCache(cacheKey);
    if (cached) return cached;

    // Cloudinary 변환 옵션 적용
    const optimizedUrl = await this.transformImageUrl(originalUrl, size);
    await this.setCache(cacheKey, optimizedUrl, 24 * 60 * 60); // 24시간
    
    return optimizedUrl;
  }

  private async transformImageUrl(url: string, size: string): Promise<string> {
    const sizeMap = {
      sm: 'w_300,h_200,c_fill',
      md: 'w_600,h_400,c_fill',
      lg: 'w_900,h_600,c_fill',
      xl: 'w_1200,h_800,c_fill'
    };

    return url.replace('/upload/', `/upload/${sizeMap[size]}/`);
  }
}
```


<strong>3.2 Progressive Image Loading</strong>


```typescript
// modules/shared/ProgressiveImage.tsx
import { useState, useEffect } from 'react';

const ProgressiveImage = ({ src, placeholder, alt, ...props }) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [imageRef, setImageRef] = useState();

  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      setImageSrc(src);
    };
  }, [src]);

  return (
    <img
      {...props}
      src={imageSrc}
      alt={alt}
      ref={setImageRef}
      className={`progressive-image ${imageSrc === placeholder ? 'loading' : 'loaded'}`}
    />
  );
};
```


<strong>Phase 4: 검색 성능 최적화 (1주)</strong>


<strong>4.1 검색 인덱스 최적화</strong>


```typescript
// lib/search/enhanced_search_index.ts
export class EnhancedSearchIndex {
  private fuse: Fuse<any>;
  private searchCache = new Map();

  constructor(pages: any[]) {
    this.fuse = new Fuse(pages, {
      keys: [
        { name: 'title', weight: 0.7 },
        { name: 'description', weight: 0.3 },
        { name: 'tags', weight: 0.2 },
        { name: 'content', weight: 0.1 }
      ],
      threshold: 0.3,
      distance: 100,
      includeScore: true,
      useExtendedSearch: true
    });
  }

  search(query: string, options?: any) {
    const cacheKey = `${query}:${JSON.stringify(options)}`;
    
    if (this.searchCache.has(cacheKey)) {
      return this.searchCache.get(cacheKey);
    }

    const results = this.fuse.search(query, options);
    this.searchCache.set(cacheKey, results);
    
    // 캐시 크기 제한
    if (this.searchCache.size > 100) {
      const firstKey = this.searchCache.keys().next().value;
      this.searchCache.delete(firstKey);
    }

    return results;
  }
}
```


<strong>4.2 검색 결과 가상화</strong>


```typescript
// modules/common/search/VirtualizedSearchResults.tsx
import { FixedSizeList as List } from 'react-window';

const VirtualizedSearchResults = ({ results, query }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <SearchResultItem result={results[index]} query={query} />
    </div>
  );

  return (
    <List
      height={400}
      itemCount={results.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
};
```


<strong>Phase 5: 성능 모니터링 및 최적화 (1주)</strong>


<strong>5.1 성능 메트릭 수집</strong>


```typescript
// lib/performance/performance_monitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  measurePageLoad() {
    if (typeof window !== 'undefined') {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      
      this.recordMetric('pageLoad', navigation.loadEventEnd - navigation.loadEventStart);
      this.recordMetric('domContentLoaded', navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart);
      this.recordMetric('firstPaint', performance.getEntriesByName('first-paint')[0]?.startTime || 0);
    }
  }

  private recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  getMetrics() {
    const result: Record<string, { avg: number; min: number; max: number }> = {};
    
    for (const [name, values] of this.metrics) {
      result[name] = {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        min: Math.min(...values),
        max: Math.max(...values)
      };
    }
    
    return result;
  }
}
```


<strong>5.2 Bundle 분석 및 최적화</strong>


```typescript
// next.config.ts
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

const nextConfig = {
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['@radix-ui/react-icons', 'lucide-react'],
  },
  webpack: (config, { dev, isServer }) => {
    // Tree shaking 최적화
    config.optimization.usedExports = true;
    config.optimization.sideEffects = false;
    
    // 코드 분할 최적화
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    };
    
    return config;
  },
};

module.exports = withBundleAnalyzer(nextConfig);
```


## <strong>📊 예상 성능 향상 효과</strong>


### <strong>캐싱 최적화</strong>

- <strong>Notion API 호출</strong>: 80% 감소
- <strong>페이지 로딩 속도</strong>: 60% 향상
- <strong>서버 리소스 사용량</strong>: 70% 감소

### <strong>렌더링 최적화</strong>

- <strong>초기 렌더링</strong>: 40% 향상
- <strong>리렌더링</strong>: 70% 감소
- <strong>메모리 사용량</strong>: 30% 감소

### <strong>이미지 최적화</strong>

- <strong>이미지 로딩</strong>: 50% 향상
- <strong>대역폭 사용량</strong>: 40% 감소
- <strong>사용자 경험</strong>: 60% 향상

## <strong>🎯 실행 우선순위</strong>


### <strong>High Priority (1-2주)</strong>

1. Notion API 캐싱 시스템 고도화
2. React 컴포넌트 메모이제이션 적용
3. 이미지 캐싱 전략 개선

### <strong>Medium Priority (2-3주)</strong>

1. 가상화 스크롤링 구현
2. 검색 성능 최적화
3. Bundle 분석 및 최적화

### <strong>Low Priority (3-4주)</strong>

1. 성능 모니터링 시스템 구축
2. A/B 테스트를 통한 최적화 검증
3. 사용자 피드백 기반 추가 최적화

---


## <strong>🚀 다음 단계</strong>


이 전략을 실행하기 위해 다음 중 어떤 부분부터 시작하고 싶으신지 알려주세요:

1. <strong>캐싱 시스템 고도화</strong> - 가장 큰 성능 향상 효과
2. <strong>React 렌더링 최적화</strong> - 사용자 경험 개선
3. <strong>이미지 최적화</strong> - 로딩 속도 개선
4. <strong>검색 성능 최적화</strong> - 검색 경험 개선

어떤 부분부터 시작하시겠습니까?


=⇒


아하! 이제 상황이 명확해졌습니다. <strong>현재 프로젝트는 이미 react-notion-x를 완전히 제거하고 Content Collections + Fumadocs 기반으로 전환된 상태</strong>입니다.


## <strong>🔍 현재 프로젝트의 실제 구조 분석</strong>


### <strong>✅ 이미 적용된 최적화:</strong>

1. <strong>react-notion-x 제거 완료</strong> - 더 이상 실시간 Notion 렌더링 없음
2. <strong>Content Collections + Fumadocs 적용</strong> - 정적 MDX 기반 렌더링
3. <strong>빌드 타임에 MDX 생성</strong> - scripts/notion-mdx-all-in-one.ts로 자동 변환
4. <strong>정적 사이트 생성</strong> - Next.js에서 정적 HTML로 빌드

<strong>❌ 현재 캐시 시스템의 문제점:</strong>


<strong>실제로는 캐시가 거의 사용되지 않습니다!</strong> 왜냐하면:

1. <strong>layout.tsx에서만 사용</strong>: fetchMenuList()만 호출
2. <strong>대부분의 데이터는 이미 정적 MDX</strong>: recordSource.getPages() 등으로 정적 데이터 사용
3. <strong>Notion API 호출 최소화</strong>: 빌드 타임에 한 번만 실행

<strong>Phase 1: 정적 빌드 최적화 (실제 효과가 큰 부분)</strong>


<strong>1.1 빌드 타임 MDX 생성 최적화</strong>


```typescript
// scripts/enhanced-notion-mdx.ts
export class EnhancedMdxGenerator {
  private cache = new Map<string, any>();
  
  async generateMdxWithCache(pageId: string) {
    const cacheKey = `mdx_${pageId}`;
    
    // 메모리 캐시 확인
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    // Notion API 호출 및 MDX 생성
    const mdxContent = await this.generateMdxFromNotion(pageId);
    
    // 캐시에 저장
    this.cache.set(cacheKey, mdxContent);
    
    return mdxContent;
  }
}
```


<strong>1.2 Content Collections 빌드 최적화</strong>


```typescript
// content-collections.ts
export default defineConfig({
  mdxOptions: {
    // 빌드 성능 최적화
    development: false,
    format: "mdx",
  },
  // 병렬 처리 최적화
  parallel: true,
  // 증분 빌드 지원
  incremental: true,
});
```


<strong>Phase 2: 런타임 성능 최적화 (실제 사용되는 부분)</strong>


<strong>2.1 검색 성능 최적화</strong>


```typescript
// lib/search/enhanced-search.ts
export class EnhancedSearch {
  private searchIndex: Map<string, SearchData> = new Map();
  
  // 빌드 타임에 검색 인덱스 생성
  buildSearchIndex(pages: any[]) {
    pages.forEach(page => {
      this.searchIndex.set(page.url, {
        title: page.data.title,
        content: page.data.content,
        tags: page.data.tags
      });
    });
  }
  
  // 메모리 기반 빠른 검색
  search(query: string) {
    // Map 기반 빠른 검색
    return Array.from(this.searchIndex.values())
      .filter(item => this.matchesQuery(item, query));
  }
}
```



<strong>2.2 이미지 최적화 (실제로 많이 사용됨)</strong>


```typescript
// lib/image/enhanced-image-processor.ts
export class EnhancedImageProcessor {
  // Cloudinary 이미지 최적화
  async optimizeImage(url: string, options: ImageOptions) {
    const optimizedUrl = await this.transformCloudinaryUrl(url, options);
    return optimizedUrl;
  }
  
  // WebP 자동 변환
  private transformCloudinaryUrl(url: string, options: ImageOptions) {
    const transformations = [
      'f_auto', // 자동 포맷 (WebP 우선)
      'q_auto', // 자동 품질
      'w_auto', // 반응형 너비
    ];
    
    return url.replace('/upload/', `/upload/${transformations.join(',')}/`);
  }
}
```


## <strong>🚀 새로운 최적화 전략 제안</strong>


### <strong>High Priority (실제 효과가 큰 부분):</strong>

1. <strong>빌드 타임 MDX 생성 최적화</strong> - 병렬 처리, 캐싱
2. <strong>Content Collections 빌드 최적화</strong> - 증분 빌드, 병렬 처리
3. <strong>검색 성능 최적화</strong> - 메모리 기반 인덱스

### <strong>Medium Priority:</strong>

1. <strong>이미지 최적화</strong> - WebP 변환, Cloudinary 최적화
2. <strong>번들 최적화</strong> - Tree shaking, 코드 분할

### <strong>Low Priority (기존 캐시 시스템):</strong>

1. <strong>Notion API 캐싱</strong> - 이미 거의 사용되지 않음
2. <strong>Redis 캐싱</strong> - 정적 사이트에서는 불필요

---


## <strong>💡 결론 및 제안</strong>


<strong>현재 상황</strong>: 이미 최적화된 정적 사이트 구조를 가지고 있음


<strong>실제 문제</strong>: 빌드 타임 성능과 런타임 검색/이미지 성능


<strong>새로운 방향</strong>


:

1. <strong>빌드 타임 최적화</strong>에 집중 (MDX 생성, Content Collections)
2. <strong>검색 성능 최적화</strong> (메모리 기반 인덱스)
3. <strong>이미지 최적화</strong> (WebP, Cloudinary)
1. <strong>빌드 타임 최적화</strong> - MDX 생성 성능 향상
2. <strong>검색 성능 최적화</strong> - 빠른 검색 구현
3. <strong>이미지 최적화</strong> - WebP 변환, Cloudinary 최적화
