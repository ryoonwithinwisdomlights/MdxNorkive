/**
 * MDX 콘텐츠 안전 변환 유틸리티 (JavaScript 백업 버전)
 *
 * 📋 파일 역할:
 * Notion에서 가져온 MDX 콘텐츠를 안전하게 처리하는 JavaScript 기반 변환기의 백업 파일입니다.
 * TypeScript 버전 개발 전의 원본 JavaScript 구현체로, 단순하고 직관적인 함수형 접근법을 사용합니다.
 *
 * 🏗️ 아키텍처: 원본 JavaScript 구현체
 *
 * ✅ 주요 장점:
 * 1. 단순하고 직관적인 구조
 *    - 함수형 프로그래밍 접근법
 *    - 복잡한 클래스 구조 없음
 *    - 이해하기 쉬운 코드 흐름
 *
 * 2. 빠른 개발과 프로토타이핑
 *    - 복잡한 설계 패턴 없음
 *    - 빠른 기능 구현 가능
 *    - 즉시 테스트 가능
 *
 * 3. 가벼운 메모리 사용량
 *    - 클래스 인스턴스 오버헤드 없음
 *    - 함수 호출 스택만 사용
 *    - 최소한의 메모리 점유
 *
 * 4. 브라우저 호환성
 *    - 순수 JavaScript로 작성
 *    - 추가 컴파일 과정 불필요
 *    - 모든 브라우저에서 실행 가능
 *
 * 5. 디버깅 용이성
 *    - 단순한 함수 호출 체인
 *    - 명확한 실행 흐름
 *    - 오류 추적 쉬움
 *
 * 🔴 주요 부작용 및 한계:
 * 1. 타입 안전성 부족
 *    - JavaScript의 동적 타입 시스템
 *    - 런타임 오류 가능성
 *    - IDE 지원 제한
 *
 * 2. 확장성 제한
 *    - 구조화된 확장 메커니즘 없음
 *    - 새로운 기능 추가 시 코드 수정 필요
 *    - 모듈화된 설계 부족
 *
 * 3. 유지보수 어려움
 *    - 함수 간 의존성 관리 어려움
 *    - 코드 재사용성 제한
 *    - 테스트 작성 복잡
 *
 * 4. 성능 최적화 한계
 *    - 고급 최적화 기법 적용 어려움
 *    - 메모이제이션 구현 복잡
 *    - 병렬 처리 구현 어려움
 *
 * 5. 코드 품질 관리 어려움
 *    - 린팅 도구 제한
 *    - 코드 포맷팅 일관성 어려움
 *    - 문서화 도구 지원 제한
 *
 * 🎯 사용 시나리오:
 *
 * ✅ 적합한 경우:
 * - 빠른 프로토타이핑
 * - 단순한 변환 로직
 * - 브라우저 환경에서 직접 실행
 * - 학습 및 교육 목적
 * - 레거시 시스템 호환성
 *
 * ❌ 부적합한 경우:
 * - 대규모 프로젝트
 * - 복잡한 비즈니스 로직
 * - 팀 개발 환경
 * - 장기 유지보수 필요
 * - 타입 안전성이 중요한 경우
 *
 * 🔧 주요 기능:
 * 1. 기본 MDX 콘텐츠 처리
 * 2. 코드 블록 보호
 * 3. 테이블 블록 수정
 * 4. 제목 블록 수정
 * 5. 안전하지 않은 태그 변환
 * 6. 링크 변환
 * 7. 중첩 링크 수정
 * 8. URL 인코딩 디코딩
 *
 * 📊 성능 특성:
 * - 처리 속도: 빠름 (단순 함수 호출)
 * - 메모리 사용량: 낮음 (함수 스택만 사용)
 * - 확장성: 낮음 (구조화된 확장 메커니즘 없음)
 * - 유지보수성: 중간 (단순한 구조)
 *
 * 🚀 최적화 기법:
 * - 함수 인라인화
 * - 불필요한 변수 제거
 * - 정규식 최적화
 * - 메모리 사용량 최소화
 */

function processMdxContent(content) {
  return fixNestedLinks(convertUnsafeTags(transformLinks(content)));
}

function decodeUrlEncodedLinks(content) {
  // 마크다운 링크에서 URL 인코딩된 텍스트만 디코딩 (URL은 그대로 유지)
  return content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
    // 링크 텍스트만 디코딩, URL은 그대로 유지
    const decodedText = decodeURIComponent(text);
    return `[${decodedText}](${url})`;
  });
}

function fixNestedLinks(content) {
  // 중첩된 링크 문제만 해결: <a> 태그 안에 마크다운 링크가 있는 경우
  // 패턴: <a href="...">[text](url)</a> → <a href="...">text</a>

  // 패턴 1: <a> 태그 안의 [**text**](url) 형태를 **text**로 변경
  content = content.replace(
    /(<a[^>]*>)(\[(\*\*[^*]+\*\*)\]\([^)]+\))(<\/a>)/g,
    "$1$3$4"
  );

  // 패턴 2: <a> 태그 안의 [**text**](url) 형태를 text로 변경 (볼드 제거)
  content = content.replace(
    /(<a[^>]*>)(\[\*\*([^*]+)\*\*\]\([^)]+\))(<\/a>)/g,
    "$1$3$4"
  );

  // 패턴 3: <a> 태그 안의 [text](url) 형태를 text로 변경 (일반 링크)
  content = content.replace(
    /(<a[^>]*>)(\[([^\]]+)\]\([^)]+\))(<\/a>)/g,
    "$1$3$4"
  );

  return content;
}

/**
 * MDX에서 문제가 있는 태그들을 안전한 문자열(HTML 엔티티)로 변환
 * 코드블록(``` ... ```) 내부는 변환하지 않음
 */
function convertUnsafeTags(content) {
  let safeContent = content;

  // 코드블록을 보호하기 위해 임시 마커로 교체
  const codeBlocks = [];
  let codeBlockIndex = 0;

  // 코드블록을 찾아서 임시 마커로 교체
  safeContent = safeContent.replace(/```[\s\S]*?```/g, (match) => {
    const marker = `__CODE_BLOCK_${codeBlockIndex}__`;
    codeBlocks[codeBlockIndex] = match;
    codeBlockIndex++;
    return marker;
  });

  // 테이블 블록을 정확히 감지하고 처리
  safeContent = safeContent.replace(
    /(\|[^|\n]*\|[^|\n]*\|[^|\n]*\n?)+/g,
    (tableMatch) => {
      // 테이블 내의 각 셀에서 태그를 HTML 엔티티로 변환
      return tableMatch.replace(/\|([^|]*)\|/g, (cellMatch, cellContent) => {
        const safeCellContent = cellContent.replace(
          /<([^>]+)>/g,
          (tagMatch, tagContent) => {
            // 테이블 내에서는 모든 태그를 HTML 엔티티로 변환
            return `&lt;${tagContent}&gt;`;
          }
        );
        return `|${safeCellContent}|`;
      });
    }
  );

  // 1. 빈 제목 수정 - 개선된 로직
  safeContent = safeContent.replace(/^#{1,6}\s*$/gm, (match) => {
    // 제목 레벨을 유지하면서 기본 제목 추가
    const level = match.match(/^#{1,6}/)[0];
    return `${level} 제목 없음`;
  });

  // 제목이 있지만 내용이 비어있거나 공백만 있는 경우 처리
  safeContent = safeContent.replace(/^#{1,6}\s*([^\n]*)$/gm, (match, title) => {
    const level = match.match(/^#{1,6}/)[0];
    const trimmedTitle = title.trim();

    // 제목이 비어있거나 공백만 있는 경우
    if (!trimmedTitle || trimmedTitle === "") {
      return `${level} 제목 없음`;
    }

    // 제목이 너무 짧고 의미가 없는 경우 (1-2자 이하)
    if (trimmedTitle.length <= 2 && !/^[a-zA-Z가-힣0-9]/.test(trimmedTitle)) {
      return `${level} 제목 없음`;
    }

    return match; // 원본 제목 유지
  });

  // 2. 마크다운 문법을 안전한 HTML 태그로 변환
  // **bold** → <strong>bold</strong> (여러 줄에 걸친 경우도 처리)
  safeContent = safeContent.replace(
    /\*\*([^*\n]+)\*\*/g,
    "<strong>$1</strong>"
  );
  // *italic* → <em>italic</em> (여러 줄에 걸친 경우도 처리)
  safeContent = safeContent.replace(/\*([^*\n]+)\*/g, "<em>$1</em>");
  // `code` → <code>code</code>
  safeContent = safeContent.replace(/`([^`\n]+)`/g, "<code>$1</code>");

  // 3. HTML 엔티티로 인코딩된 태그를 실제 태그로 변환
  safeContent = safeContent.replace(/&lt;em&gt;/g, "<em>");
  safeContent = safeContent.replace(/&lt;\/em&gt;/g, "</em>");
  safeContent = safeContent.replace(/&lt;strong&gt;/g, "<strong>");
  safeContent = safeContent.replace(/&lt;\/strong&gt;/g, "</strong>");
  safeContent = safeContent.replace(/&lt;code&gt;/g, "<code>");
  safeContent = safeContent.replace(/&lt;\/code&gt;/g, "</code>");

  // 4. 닫히지 않은 태그 처리
  // 닫히지 않은 <em> 태그 처리
  safeContent = safeContent.replace(/<em>([^<]*?)(?=\n|$)/g, "<em>$1</em>");
  // 닫히지 않은 <strong> 태그 처리
  safeContent = safeContent.replace(
    /<strong>([^<]*?)(?=\n|$)/g,
    "<strong>$1</strong>"
  );
  // 닫히지 않은 <code> 태그 처리
  safeContent = safeContent.replace(
    /<code>([^<]*?)(?=\n|$)/g,
    "<code>$1</code>"
  );

  // 5. 마크다운 인용문 보호 (HTML 태그 처리 전에 임시 마커로 교체)
  const blockquotes = [];
  let blockquoteIndex = 0;

  // 마크다운 인용문을 임시 마커로 교체
  safeContent = safeContent.replace(/^>\s*(.+)$/gm, (match, content) => {
    const marker = `__BLOCKQUOTE_${blockquoteIndex}__`;
    blockquotes[blockquoteIndex] = match;
    blockquoteIndex++;
    return marker;
  });

  // 일반 텍스트에서 <로 시작하고 >로 끝나는 모든 텍스트를 처리 (더 포괄적)
  safeContent = safeContent.replace(/<([^>]+)>/g, (match, tagContent) => {
    // 태그 내용에서 첫 번째 단어를 태그명으로 추출 (공백, 따옴표, 등호 등을 고려)
    const tagContentFirst = tagContent.trim().split(/[\s='"]+/)[0];
    const tagName = tagContentFirst.toLowerCase();

    // MDX에서 안전하게 사용할 수 있는 HTML 태그들
    const SELECTORS = [
      // 제목 태그
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",

      // 텍스트 관련
      "p",
      "span",
      "div",
      "br",
      "hr",
      "strong",
      "b",
      "em",
      "i",
      "u",
      "s",
      "del",
      "ins",
      "mark",
      "small",
      "sub",
      "sup",

      // 링크
      "a",

      // 인용
      "blockquote",
      "cite",

      // 코드
      "code",
      "pre",
      "kbd",
      "samp",
      "var",

      // 목록
      "ul",
      "ol",
      "li",
      "dl",
      "dt",
      "dd",

      // 테이블
      "table",
      "thead",
      "tbody",
      "tfoot",
      "tr",
      "td",
      "th",
      "caption",
      "colgroup",
      "col",

      // 미디어
      "img",
      "video",
      "audio",
      "source",
      "track",
      "figure",
      "figcaption",

      // 폼 요소 (일부)
      "form",
      "input",
      "textarea",
      "select",
      "option",
      "optgroup",
      "button",
      "label",
      "fieldset",
      "legend",

      // 기타
      "details",
      "summary",
      "dialog",
      "menu",
      "menuitem",
      "abbr",
      "acronym",
      "address",
      "article",
      "aside",
      "footer",
      "header",
      "main",
      "nav",
      "section",
      "time",
      "data",
      "meter",
      "progress",

      // SVG (기본)
      "svg",
      "path",
      "circle",
      "rect",
      "line",
      "polyline",
      "polygon",
      "ellipse",
      "text",
      "g",
      "defs",
      "use",

      // MathML (기본)
      "math",
      "mrow",
      "mi",
      "mo",
      "mn",
      "msup",
      "msub",
      "msubsup",
      "mfrac",
      "msqrt",
      "mroot",

      // 기타 안전한 태그들
      "ruby",
      "rt",
      "rp",
      "bdi",
      "bdo",
      "wbr",
      "nobr",
      "spacer",
      "embed",
      "object",
      "param",
      "map",
      "area",
      //커스텀
      "YoutubeWrapper",
      "EmbededWrapper",
      "FileWrapper",
      "GoogleDriveWrapper",
      "BookMarkWrapper",
    ];

    // 1. 허용된 HTML 태그는 그대로 유지 (대소문자 구분 없이)
    if (SELECTORS.includes(tagName) || SELECTORS.includes(tagContentFirst)) {
      return match;
    }

    // 2. 허용된 태그에 JSX 속성이 있는 경우 허용 (className, id, style 등)
    if (
      SELECTORS.includes(tagName) &&
      (tagContent.includes("className=") ||
        tagContent.includes("id=") ||
        tagContent.includes("style=") ||
        tagContent.includes("src=") ||
        tagContent.includes("href=") ||
        tagContent.includes("alt=") ||
        tagContent.includes("target=") ||
        tagContent.includes("rel=") ||
        tagContent.includes("onClick=") ||
        tagContent.includes("onChange=") ||
        tagContent.includes("value=") ||
        tagContent.includes("type=") ||
        tagContent.includes("placeholder=") ||
        tagContent.includes("disabled=") ||
        tagContent.includes("required=") ||
        tagContent.includes("checked=") ||
        tagContent.includes("selected=") ||
        tagContent.includes("readonly=") ||
        tagContent.includes("maxlength=") ||
        tagContent.includes("minlength=") ||
        tagContent.includes("pattern=") ||
        tagContent.includes("autocomplete=") ||
        tagContent.includes("autofocus=") ||
        tagContent.includes("form=") ||
        tagContent.includes("name=") ||
        tagContent.includes("tabindex=") ||
        tagContent.includes("title=") ||
        tagContent.includes("data-") ||
        tagContent.includes("aria-"))
    ) {
      return match;
    }

    // 3. 닫는 태그는 허용된 태그만 허용 (</tag>)
    if (tagContent.startsWith("/")) {
      const closingTagName = tagContent.substring(1).toLowerCase();
      const closingTagOriginal = tagContent.substring(1);
      if (
        SELECTORS.includes(closingTagName) ||
        SELECTORS.includes(closingTagOriginal)
      ) {
        return match;
      }
    }

    // 4. 그 외의 모든 것은 HTML 엔티티로 변환
    return `&lt;${tagContent}&gt;`;
  });

  // MDX 확장 문법 제거
  safeContent = safeContent.replace(/\{:[^}]+\}/g, "");

  // 코드블록을 원래대로 복원
  for (let i = codeBlocks.length - 1; i >= 0; i--) {
    const marker = `__CODE_BLOCK_${i}__`;
    const codeBlock = codeBlocks[i];
    // 단순 문자열 교체로 줄바꿈 보존
    safeContent = safeContent.split(marker).join(codeBlock);
  }

  // 마크다운 인용문 복원
  for (let i = blockquotes.length - 1; i >= 0; i--) {
    const marker = `__BLOCKQUOTE_${i}__`;
    const blockquote = blockquotes[i];
    // 단순 문자열 교체로 줄바꿈 보존
    safeContent = safeContent.split(marker).join(blockquote);
  }

  return safeContent;
}

function transformLinks(content) {
  let safeContent = content;
  safeContent = transformYouTubeLinks(safeContent);
  safeContent = transformEmbededLinks(safeContent);
  safeContent = transformFileLinks(safeContent);
  safeContent = transformGoogleDriveLinks(safeContent);
  safeContent = transformBookMarkLinks(safeContent);
  return safeContent;
}

function transformGoogleDriveLinks(content) {
  return content.replace(
    /\[([^\]]+)\]\((https?:\/\/drive\.google\.com\/file\/d\/[^\s)]+)\)/g,
    (match, linkText, url) => {
      return `<GoogleDriveWrapper names={"${linkText}"} urls={"${url}"} />`;
    }
  );
}

/**
 * 문서 링크를 FileWrapper 컴포넌트로 변환 (PDF, DOC, DOCX, RTF, TXT 등)
 * [파일명.pdf](URL) → <FileWrapper names={"파일명.pdf"} urls={"URL"} />
 * [파일명.docx](URL) → <FileWrapper names={"파일명.docx"} urls={"URL"} />
 */
function transformFileLinks(content) {
  // 지원하는 문서 확장자들
  const documentExtensions = [
    "pdf",
    "doc",
    "docx",
    "rtf",
    "txt",
    "md",
    "odt",
    "PDF",
    "DOC",
    "DOCX",
    "RTF",
    "TXT",
    "MD",
    "ODT",
  ];

  // 문서 링크 패턴 매칭: [파일명.확장자](URL)
  return content.replace(
    /\[([^\]]+\.(pdf|doc|docx|rtf|txt|md|odt))\]\(([^)]+)\)/gi,
    (match, fileName, extension, url) => {
      // 확장자를 포함한 전체 파일명 유지
      return `<FileWrapper names={"${fileName}"} urls={"${url}"} />`;
    }
  );
}

/**
 * YouTube 링크를 YoutubeWrapper 컴포넌트로 변환
 * [video](https://youtu.be/VIDEO_ID) → <YoutubeWrapper names={"video"} urls={"https://youtu.be/VIDEO_ID"} />
 */
function transformYouTubeLinks(content) {
  // YouTube 링크 패턴 매칭 (youtu.be, youtube.com, youtube-nocookie.com 등)
  // [video](https://youtu.be/VIDEO_ID?si=VIDEO_ID) → <YoutubeWrapper names={"video"} urls={"https://youtu.be/VIDEO_ID"} />
  // [video] 텍스트가 있을 때만 변환
  return content.replace(
    /\[video\]\((https?:\/\/(www\.)?(youtube\.com|youtu\.be|youtube-nocookie\.com)\/[^\s)]+)\)/g,
    (match, url) => {
      // URL에서 쿼리 파라미터 제거 (si= 등)
      const cleanUrl = url.split("?")[0];
      return `<YoutubeWrapper names={"video"} urls={"${cleanUrl}"} />`;
    }
  );
}

function transformBookMarkLinks(content) {
  return content.replace(
    /\[bookmark\]\((https?:\/\/[^\s)]+)\)/g,
    (match, url) => {
      return `<BookMarkWrapper names={"bookmark"} urls={"${url}"} />`;
    }
  );
}

function transformEmbededLinks(content) {
  return content.replace(/\[embed\]\((https?:\/\/[^\s)]+)\)/g, (match, url) => {
    return `<EmbededWrapper names={"embed"} urls={"${url}"} />`;
  });
}

module.exports = {
  processMdxContent,
  convertUnsafeTags,
  decodeUrlEncodedLinks,
  transformYouTubeLinks,
  transformFileLinks,
};
